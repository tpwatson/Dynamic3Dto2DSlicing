<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Layered-Painting Walking Sim (WebGL2)</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ddd;font-family:system-ui}
  #ui{position:fixed;left:12px;top:72px;z-index:9;background:#0008;padding:8px 10px;border-radius:8px;max-width:360px}
  #ui label{display:block;font-size:12px;margin:6px 0 2px}
  #ui input[type=range]{width:220px;vertical-align:middle}
  #ui .val{display:inline-block;width:70px;text-align:right;font-size:12px;opacity:0.9}
  /* scope fullscreen sizing to primary GL canvas only */
  #gl{display:block;width:100vw;height:100vh;background:#050505}
  .btn{display:inline-block;background:#222;border:1px solid #444;padding:6px 8px;border-radius:6px;cursor:pointer}
  #uiToggle{position:fixed;left:12px;top:12px;z-index:10}
  /* Diorama card overlay (GL-drawn) — no DOM element needed */
  /* Black mirror overlay image */
  #mirrorOverlay{position:fixed;left:50%;top:50%;z-index:12;height:100vh;width:auto;pointer-events:none;user-select:none;object-fit:contain;transform:translate(-50%, -50%);} 
  /* Mobile virtual joysticks */
  .joy{position:fixed;bottom:22px;width:180px;height:180px;border-radius:50%;background:radial-gradient(closest-side, #ffffff10 0%, #ffffff08 60%, #00000000 61%);border:1px solid #333;display:none;z-index:13;touch-action:none}
  #joyL{left:22px}
  #joyR{right:22px}
  .joy .knob{position:absolute;left:50%;top:50%;width:72px;height:72px;border-radius:50%;background:#ffffff20;border:1px solid #666;transform:translate(-50%, -50%)}
  .joy.active .knob{background:#ffffff35}
  @media (hover: none) and (pointer: coarse){ .joy{display:block} }
</style>
</head>
<body>
<div id="uiToggle" class="btn">Hide UI (H)</div>
<div id="ui">
  <div><b>Airplane</b> — W/S throttle, A/D roll, Arrow Up/Down pitch, Shift afterburner. Plane starts on ground.</div>
  <div>Layers: 14 • Stroke size: 8px • 5% random variation</div>
  <div id="status">loading heightmap…</div>
  <div style="margin-top:6px"><span class="btn" id="recenter">Recenter (R)</span></div>
  <div style="margin-top:8px">
    <label>View Far <span class="val" id="v_viewFar"></span></label>
    <input id="ctl_viewFar" type="range" min="50" max="50000" step="10">
    <label>Layer Max Dist <span class="val" id="v_layerMax"></span></label>
    <input id="ctl_layerMax" type="range" min="50" max="50000" step="10">
    <label>Stroke Px <span class="val" id="v_stroke"></span></label>
    <input id="ctl_stroke" type="range" min="2" max="48" step="1">
    <label>Variation <span class="val" id="v_var"></span></label>
    <input id="ctl_var" type="range" min="0" max="0.6" step="0.01">
    <label>Height Scale <span class="val" id="v_hscale"></span></label>
    <input id="ctl_hscale" type="range" min="10" max="1500" step="10">
    <label>Checker Size <span class="val" id="v_chkSize"></span></label>
    <input id="ctl_chkSize" type="range" min="1" max="200" step="1">
    <label>Checker Opacity <span class="val" id="v_chkAlpha"></span></label>
    <input id="ctl_chkAlpha" type="range" min="0" max="1" step="0.01">
    <label><input id="ctl_chkScreen" type="checkbox" checked> Checker Screen-space (per layer)</label>
    <label><input id="ctl_outlineOn" type="checkbox" checked> Edge Outlines</label>
    <label>Outline Sensitivity <span class="val" id="v_outScale"></span></label>
    <input id="ctl_outScale" type="range" min="0" max="30" step="1">
    <label>Outline Intensity <span class="val" id="v_outInt"></span></label>
    <input id="ctl_outInt" type="range" min="0" max="1" step="0.01">
    <label><input id="ctl_waveOn" type="checkbox"> Magic Wave (per layer)</label>
    <label>Wave Amp <span class="val" id="v_waveAmp"></span></label>
    <input id="ctl_waveAmp" type="range" min="0" max="800" step="10">
    <label>Wave Speed <span class="val" id="v_waveSpeed"></span></label>
    <input id="ctl_waveSpeed" type="range" min="0" max="8" step="0.1">
    <label>Wave Phase/Layer <span class="val" id="v_wavePhase"></span></label>
    <input id="ctl_wavePhase" type="range" min="0" max="3.1415" step="0.01">
    <label>Layer Passes (perf) <span class="val" id="v_layerPasses"></span></label>
    <input id="ctl_layerPasses" type="range" min="1" max="14" step="1">
    <label>Layer Res Scale (perf) <span class="val" id="v_resScale"></span></label>
    <input id="ctl_resScale" type="range" min="0.25" max="1" step="0.05">
    <label><input id="ctl_lockLayer" type="checkbox" checked> Lock Layer Max to View Far</label>
    <label><input id="ctl_starsSky" type="checkbox" checked> Stars/Moon Sky</label>
    <label><input id="ctl_moonOnSky" type="checkbox" checked> Moon</label>
    <label>Star Density <span class="val" id="v_starDensity"></span></label>
    <input id="ctl_starDensity" type="range" min="200" max="2000" step="10">
    <label><input id="ctl_asciiOn" type="checkbox"> ASCII Mode</label>
    <label>ASCII Cell Px <span class="val" id="v_asciiCell"></span></label>
    <input id="ctl_asciiCell" type="range" min="4" max="48" step="1">
    <label>ASCII Brightness <span class="val" id="v_asciiBright"></span></label>
    <input id="ctl_asciiBright" type="range" min="0.5" max="3" step="0.05">
    <label>ASCII Background Darken <span class="val" id="v_asciiDark"></span></label>
    <input id="ctl_asciiDark" type="range" min="0" max="1" step="0.01">
  </div>
</div>
  <!-- <div id="bandUi" style="margin-top:8px">
    <label>Preview Band (isolated)</label>
    <div id="bands"></div>
  </div> -->
<canvas id="gl"></canvas>
<img id="mirrorOverlay" src="blackmirror.png" alt="" style="display:none" />
<div id="joyL" class="joy"><div class="knob"></div></div>
<div id="joyR" class="joy"><div class="knob"></div></div>

<!-- Diorama Card will be drawn by WebGL inside the main canvas; no extra DOM needed -->

<script src="joystick.js"></script>
<script src="skybox.js"></script>
<script src="terrain.js"></script>
<script src="postcompose.js"></script>
<script src="gltf.js"></script>

<script>
/*** ---------- Config ---------- ***/
const HEIGHTMAP_DATA_URL = `heightmap2.png`;
/*
If you want to use your file instead, e.g. "heightmap.png", put it in same folder and:
const HEIGHTMAP_DATA_URL = "heightmap.png";
*/
// Equirectangular sky texture
const SKYBOX_URL = `skybox1.jpg`;
const DEBUG_DIRECT_DRAW = false; // disable direct-draw to avoid duplicate plane renders
const PLAYER_YAW_OFFSET = 0.0; // control yaw purely via airplane state
// These are only backups; auto-alignment below determines the proper basis
let PLAYER_MODEL_YAW_FIX = 0.0;
let PLAYER_MODEL_PITCH_FIX = 0.0;
let PLAYER_MODEL_ROLL_FIX = 0.0;

// Generate a procedural heightmap instead of loading external files
function generateHeightmap(width, height) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  
  // Create a gradient background (lowlands)
  const gradient = ctx.createLinearGradient(0, 0, width, height);
  gradient.addColorStop(0, '#2d4a2d');   // Dark green
  gradient.addColorStop(0.5, '#4a6b4a'); // Medium green
  gradient.addColorStop(1, '#2d4a2d');   // Dark green
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
  
  // Add mountains using multiple noise layers
  for (let i = 0; i < 5; i++) {
    const scale = 50 + i * 30;
    const amplitude = 0.3 - i * 0.05;
    const offsetX = Math.random() * 1000;
    const offsetY = Math.random() * 1000;
    
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height; y++) {
        const noise = (Math.sin((x + offsetX) / scale) * Math.cos((y + offsetY) / scale) + 1) / 2;
        const current = ctx.getImageData(x, y, 1, 1).data[0] / 255;
        const newValue = Math.min(1, current + noise * amplitude);
        
        // Color based on height
        let r, g, b;
        if (newValue < 0.4) {
          // Lowlands - green
          r = 45; g = 74; b = 45;
        } else if (newValue < 0.7) {
          // Midlands - brown
          r = 139; g = 115; b = 85;
        } else {
          // Highlands - white/snow
          r = 240; g = 240; b = 245;
        }
        
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }
  
  return canvas;
}

// Use external heightmap image provided by user
const FINAL_DATA_URL = HEIGHTMAP_DATA_URL;

  // Terrain resolution (vertices per side)
  const GRID = 512;           // try 128–512
const SIZE = 5000.0;         // world size (XZ span)
const HEIGHT_SCALE = 1600.0; // how tall the white peaks get
// Camera FOV used for both projection and skybox ray reconstruction
const FOVY = 60 * Math.PI / 180;

// Movement
const LOOK_SENS = 0.0023;   // mouse (disabled in airplane mode)
const KEY_LOOK_SPEED = 1.8; // not used in airplane mode
const GRAV = 25.0;
const EYE_HEIGHT = 2.0;     // not used in airplane mode
// --- Airplane sim constants ---
const AFTERBURNER_MULT = 3.0;     // Shift
const THRUST_BASE = 140.0;        // units/sec^2 at full throttle
const DRAG_COEFF = 0.02;          // quadratic drag
const MAX_SPEED = 380.0;          // soft cap; drag prevents exceeding much
const TAKEOFF_SPEED = 45.0;       // must exceed and pitch up to leave ground
const PITCH_RATE = 0.9;           // rad/sec (Arrow Up/Down)
const ROLL_RATE  = 1.8;           // rad/sec (A/D)
const MAX_PITCH  = 0.6;           // ~34° up/down
const MAX_ROLL   = 1.2;           // ~69°
const BANK_TURN_RATE = 2.8;       // yaw rad/sec contribution at full bank (scaled by speed)
const MIN_TURN_RATE = 0.7;        // base yaw even at low speeds so A/D always changes heading
const ROLL_RETURN_RATE = 2.2;     // rad/sec return-to-level when no roll input
const PLANE_CLEARANCE = 3.0;      // meters above terrain to consider "on ground"
const CAMERA_FOLLOW_DIST = 70.0;  // meters behind plane
const CAMERA_FOLLOW_HEIGHT = 20.0;// meters above plane along up vector
const CAMERA_SPRING = 6.0;        // higher = snappier follow
const CAMERA_ORIENT_SPRING = 8.0; // smoothing for yaw/pitch follow
// Frame rate cap (testing)
const FPS_CAP_ENABLED = true;
const FPS_CAP = 30; // target FPS when cap is enabled
// Sprint/stamina (sedentary baseline)
const SPRINT_SPEED_TOP = 60.0;   // m/s for first ~5s
const SPRINT_SPEED_LONG = 50.0;  // m/s for next ~20-30s
const SPRINT_TOP_DURATION = 5.0; // seconds at 60
const SPRINT_LONG_DURATION = 25.0; // seconds at 50
const SPRINT_DECAY_DURATION = 20.0; // seconds to taper 50->0 if holding sprint
const SPRINT_TOTAL_DURATION = SPRINT_TOP_DURATION + SPRINT_LONG_DURATION + SPRINT_DECAY_DURATION; // ~50s
const STAMINA_DRAIN_PER_SEC = 1.0 / SPRINT_TOTAL_DURATION; // drains to 0 in ~50s of continuous sprinting
const STAMINA_RECOVER_REST = 1.0 / 45.0;  // full recover in ~45s if resting
const STAMINA_RECOVER_MOVE = 1.0 / 90.0;  // full recover in ~90s if walking

// Painterly / layers
const LAYERS = 14;
let VIEW_FAR = 50000.0;          // extend far plane for full terrain visibility
let LAYER_MAX_DIST = 50000.0;    // match view distance so all bands cover horizon
let STROKE_PX = 4.0;          // base “pixel/brush” size (screen-space)
let VARIATION = 0.05;         // subtle variation
let CHECKER_SIZE = 4.0;      // world units per checker cell
let CHECKER_ALPHA = 0.0;      // disable overlay for maximum clarity
 let CHECKER_SCREEN = true;     // when true, draw checker in screen-space per layer
// Outline defaults
let OUTLINE_ON = true;
let OUTLINE_SCALE = 4;       // sensitivity multiplier (higher catches more edges)
let OUTLINE_INTENSITY = 0.25;   // 0..1, how black the edge goes
let OUTLINE_BAND = 0;          // outline only the nearest band by default
let LAYER_PASSES = 14;         // how many bands to render (near-first)
let RES_SCALE = 1.0;           // render bands at full resolution
let LOCK_LAYER_TO_VIEW = true; // keep LAYER_MAX_DIST tracking VIEW_FAR
// Magic wave effect
let WAVE_ON = false;
let WAVE_AMP = 0.0;       // meters of vertical offset
let WAVE_SPEED = 2.0;     // radians per second
let WAVE_PHASE = 0.6;     // radians phase difference per layer

// ASCII post-processing
let ASCII_ON = false;
let ASCII_CELL_PX = 12;
let ASCII_BRIGHTNESS = 1.6;
let ASCII_BG_DARKEN = 0.9;
let ASCII_GAMMA = 1.0;

/*** ---------- WebGL2 Boilerplate ---------- ***/
const canvas = document.getElementById('gl');
const statusEl = document.getElementById('status');
const recenterBtn = document.getElementById('recenter');

let gl; // declare before first use (resize() checks this)
// Skybox handled by skybox.js

function resize() {
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const w = Math.floor(window.innerWidth * dpr);
  const h = Math.floor(window.innerHeight * dpr);
  canvas.width = w; canvas.height = h;
  canvas.style.width = '100vw'; canvas.style.height = '100vh';
  // Recreate FBOs after gl is initialized in boot sequence
  if(typeof gl !== 'undefined' && gl){ if(typeof postCreateLayerTargets==='function') postCreateLayerTargets(gl, canvas.width, canvas.height, LAYERS, RES_SCALE); }
  if(typeof gl !== 'undefined' && gl && ASCII_ON){ if(typeof postEnsureSceneTarget==='function') postEnsureSceneTarget(gl, canvas.width, canvas.height); }
}
resize(); addEventListener('resize', resize);

gl = canvas.getContext('webgl2', {antialias:false, alpha:false, powerPreference:'high-performance'});
if(!gl){ alert('WebGL2 required'); throw new Error('No WebGL2'); }
// Show GPU/driver info to help diagnose perf differences
try{
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const renderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : 'unknown';
  const vendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : 'unknown';
  const dprInfo = Math.min(2, window.devicePixelRatio || 1);
  if(statusEl) statusEl.textContent = `GPU: ${renderer} (${vendor}) — DPR: ${dprInfo} — loading heightmap…`;
}catch(e){ /* ignore */ }
// Initialize layer targets once GL exists
if(typeof postCreateLayerTargets==='function') postCreateLayerTargets(gl, canvas.width, canvas.height, LAYERS, RES_SCALE);

// UI bindings
const ctlViewFar = document.getElementById('ctl_viewFar');
const ctlLayerMax = document.getElementById('ctl_layerMax');
const ctlStroke = document.getElementById('ctl_stroke');
const ctlVar = document.getElementById('ctl_var');
const ctlHScale = document.getElementById('ctl_hscale');
const ctlChkSize = document.getElementById('ctl_chkSize');
const ctlChkAlpha = document.getElementById('ctl_chkAlpha');
const ctlChkScreen = document.getElementById('ctl_chkScreen');
const ctlOutlineOn = document.getElementById('ctl_outlineOn');
const ctlOutScale = document.getElementById('ctl_outScale');
const ctlOutInt = document.getElementById('ctl_outInt');
const ctlWaveOn = document.getElementById('ctl_waveOn');
const ctlWaveAmp = document.getElementById('ctl_waveAmp');
const ctlWaveSpeed = document.getElementById('ctl_waveSpeed');
const ctlWavePhase = document.getElementById('ctl_wavePhase');
const ctlLayerPasses = document.getElementById('ctl_layerPasses');
const ctlResScale = document.getElementById('ctl_resScale');
const ctlLockLayer = document.getElementById('ctl_lockLayer');
const ctlStarsSky = document.getElementById('ctl_starsSky');
const ctlMoonOnSky = document.getElementById('ctl_moonOnSky');
const ctlStarDensity = document.getElementById('ctl_starDensity');
const ctlAsciiOn = document.getElementById('ctl_asciiOn');
const ctlAsciiCell = document.getElementById('ctl_asciiCell');
const ctlAsciiBright = document.getElementById('ctl_asciiBright');
const ctlAsciiDark = document.getElementById('ctl_asciiDark');
const vViewFar = document.getElementById('v_viewFar');
const vLayerMax = document.getElementById('v_layerMax');
const vStroke = document.getElementById('v_stroke');
const vVar = document.getElementById('v_var');
const vHScale = document.getElementById('v_hscale');
const vChkSize = document.getElementById('v_chkSize');
const vChkAlpha = document.getElementById('v_chkAlpha');
const vOutScale = document.getElementById('v_outScale');
const vOutInt = document.getElementById('v_outInt');
const vWaveAmp = document.getElementById('v_waveAmp');
const vWaveSpeed = document.getElementById('v_waveSpeed');
const vWavePhase = document.getElementById('v_wavePhase');
const vLayerPasses = document.getElementById('v_layerPasses');
const vResScale = document.getElementById('v_resScale');
const vStarDensity = document.getElementById('v_starDensity');
const vAsciiCell = document.getElementById('v_asciiCell');
const vAsciiBright = document.getElementById('v_asciiBright');
const vAsciiDark = document.getElementById('v_asciiDark');
const bandsDiv = document.getElementById('bands');
const uiRoot = document.getElementById('ui');
const bandUiRoot = document.getElementById('bandUi');
const uiToggle = document.getElementById('uiToggle');
let uiHidden = false;

function setUiHidden(v){
  uiHidden = v;
  if(uiRoot) uiRoot.style.display = v ? 'none' : '';
  if(bandUiRoot) bandUiRoot.style.display = v ? 'none' : '';
  if(uiToggle) uiToggle.textContent = v ? 'Show UI (H)' : 'Hide UI (H)';
}
if(uiToggle){ uiToggle.addEventListener('click', ()=> setUiHidden(!uiHidden)); }

function syncUI(){
  ctlViewFar.value = VIEW_FAR;
  ctlLayerMax.value = LAYER_MAX_DIST;
  ctlStroke.value = STROKE_PX;
  ctlVar.value = VARIATION;
  ctlHScale.value = HEIGHT_SCALE;
  ctlChkSize.value = CHECKER_SIZE;
  ctlChkAlpha.value = CHECKER_ALPHA;
  ctlOutlineOn.checked = OUTLINE_ON;
  ctlOutScale.value = OUTLINE_SCALE;
  ctlOutInt.value = OUTLINE_INTENSITY;
  if(ctlChkScreen) ctlChkScreen.checked = CHECKER_SCREEN;
  ctlLayerPasses.value = LAYER_PASSES;
  ctlResScale.value = RES_SCALE;
  ctlLockLayer.checked = LOCK_LAYER_TO_VIEW;
  if(ctlStarsSky){ ctlStarsSky.checked = true; }
  if(ctlMoonOnSky){ ctlMoonOnSky.checked = true; }
  if(ctlStarDensity){ ctlStarDensity.value = 900; }
  if(ctlAsciiOn){ ctlAsciiOn.checked = ASCII_ON; }
  if(ctlAsciiCell){ ctlAsciiCell.value = ASCII_CELL_PX; }
  if(ctlAsciiBright){ ctlAsciiBright.value = ASCII_BRIGHTNESS; }
  if(ctlAsciiDark){ ctlAsciiDark.value = ASCII_BG_DARKEN; }
  if(ctlWaveOn){ ctlWaveOn.checked = WAVE_ON; }
  if(ctlWaveAmp){ ctlWaveAmp.value = WAVE_AMP; }
  if(ctlWaveSpeed){ ctlWaveSpeed.value = WAVE_SPEED; }
  if(ctlWavePhase){ ctlWavePhase.value = WAVE_PHASE; }
  vViewFar.textContent = VIEW_FAR.toFixed(0);
  vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0);
  vStroke.textContent = STROKE_PX.toFixed(0);
  vVar.textContent = VARIATION.toFixed(2);
  vHScale.textContent = HEIGHT_SCALE.toFixed(0);
  vChkSize.textContent = CHECKER_SIZE.toFixed(0);
  vChkAlpha.textContent = CHECKER_ALPHA.toFixed(2);
  vOutScale.textContent = OUTLINE_SCALE.toFixed(2);
  vOutInt.textContent = OUTLINE_INTENSITY.toFixed(2);
  vLayerPasses.textContent = LAYER_PASSES.toString();
  vResScale.textContent = RES_SCALE.toFixed(2);
  if(vStarDensity) vStarDensity.textContent = '900';
  if(vAsciiCell) vAsciiCell.textContent = ASCII_CELL_PX.toFixed(0);
  if(vAsciiBright) vAsciiBright.textContent = ASCII_BRIGHTNESS.toFixed(2);
  if(vAsciiDark) vAsciiDark.textContent = ASCII_BG_DARKEN.toFixed(2);
  if(vWaveAmp) vWaveAmp.textContent = WAVE_AMP.toFixed(0);
  if(vWaveSpeed) vWaveSpeed.textContent = WAVE_SPEED.toFixed(2);
  if(vWavePhase) vWavePhase.textContent = WAVE_PHASE.toFixed(2);
}
syncUI();

// Build band preview buttons 0..13 and an All toggle
// function buildBandButtons(){
//   bandsDiv.innerHTML = '';
//   const btnAll = document.createElement('span');
//   btnAll.className = 'btn';
//   btnAll.textContent = 'All';
//   btnAll.onclick = ()=>{ activeBand = -1; };
//   bandsDiv.appendChild(btnAll);
//   for(let i=0;i<LAYERS;i++){
//     const b = document.createElement('span');
//     b.className = 'btn';
//     b.style.marginLeft = '4px';
//     b.textContent = String(i+1);
//     b.onclick = ()=>{ activeBand = i; };
//     bandsDiv.appendChild(b);
//   }
// }
// buildBandButtons();

// Optional: stamina readout in status line
function updateStatus(){
  if(!statusEl) return;
  const spd = (plane && plane.speed) ? plane.speed : 0;
  const alt = (plane && plane.pos) ? (plane.pos.y - sampleTerrainHeightAtWorld(plane.pos.x, plane.pos.z, SIZE)) : 0;
  statusEl.textContent = `speed ${spd.toFixed(0)} m/s — altitude ${alt.toFixed(0)} m`;
}

ctlViewFar.addEventListener('input', ()=>{ VIEW_FAR = Number(ctlViewFar.value); vViewFar.textContent = VIEW_FAR.toFixed(0); });
ctlLayerMax.addEventListener('input', ()=>{ LAYER_MAX_DIST = Number(ctlLayerMax.value); vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0); });
ctlStroke.addEventListener('input', ()=>{ STROKE_PX = Number(ctlStroke.value); vStroke.textContent = STROKE_PX.toFixed(0); });
ctlVar.addEventListener('input', ()=>{ VARIATION = Number(ctlVar.value); vVar.textContent = VARIATION.toFixed(2); });
ctlHScale.addEventListener('change', ()=>{ // rebuild terrain with new vertical scale
  HEIGHT_SCALE = Number(ctlHScale.value);
  vHScale.textContent = HEIGHT_SCALE.toFixed(0);
  statusEl.textContent = 'rebuilding terrain…';
  // Re-load and rebuild to apply new scale consistently
  loadImage(FINAL_DATA_URL).then(img=>{ buildTerrainFromImage(gl, img, GRID, SIZE, HEIGHT_SCALE); statusEl.textContent='ready.'; recenter(); });
});
ctlChkSize.addEventListener('input', ()=>{ CHECKER_SIZE = Number(ctlChkSize.value); vChkSize.textContent = CHECKER_SIZE.toFixed(0); });
ctlChkAlpha.addEventListener('input', ()=>{ CHECKER_ALPHA = Number(ctlChkAlpha.value); vChkAlpha.textContent = CHECKER_ALPHA.toFixed(2); });
  if(ctlChkScreen){ ctlChkScreen.addEventListener('change', ()=>{ CHECKER_SCREEN = ctlChkScreen.checked; }); }
ctlLayerPasses.addEventListener('input', ()=>{ LAYER_PASSES = Math.max(1, Math.min(LAYERS, Number(ctlLayerPasses.value))); vLayerPasses.textContent = LAYER_PASSES.toString(); });
ctlResScale.addEventListener('input', ()=>{ RES_SCALE = Number(ctlResScale.value); vResScale.textContent = RES_SCALE.toFixed(2); if(typeof postCreateLayerTargets==='function') postCreateLayerTargets(gl, canvas.width, canvas.height, LAYERS, RES_SCALE); });
// Outline controls
if(ctlOutlineOn){ ctlOutlineOn.addEventListener('change', ()=>{ OUTLINE_ON = ctlOutlineOn.checked; }); }
if(ctlOutScale){ ctlOutScale.addEventListener('input', ()=>{ OUTLINE_SCALE = Number(ctlOutScale.value); vOutScale.textContent = OUTLINE_SCALE.toFixed(2); }); }
if(ctlOutInt){ ctlOutInt.addEventListener('input', ()=>{ OUTLINE_INTENSITY = Number(ctlOutInt.value); vOutInt.textContent = OUTLINE_INTENSITY.toFixed(2); }); }
if(ctlWaveOn){ ctlWaveOn.addEventListener('change', ()=>{ WAVE_ON = ctlWaveOn.checked; }); }
if(ctlWaveAmp){ ctlWaveAmp.addEventListener('input', ()=>{ WAVE_AMP = Number(ctlWaveAmp.value); vWaveAmp.textContent = WAVE_AMP.toFixed(0); }); }
if(ctlWaveSpeed){ ctlWaveSpeed.addEventListener('input', ()=>{ WAVE_SPEED = Number(ctlWaveSpeed.value); vWaveSpeed.textContent = WAVE_SPEED.toFixed(2); }); }
if(ctlWavePhase){ ctlWavePhase.addEventListener('input', ()=>{ WAVE_PHASE = Number(ctlWavePhase.value); vWavePhase.textContent = WAVE_PHASE.toFixed(2); }); }
ctlLockLayer.addEventListener('change', ()=>{ LOCK_LAYER_TO_VIEW = ctlLockLayer.checked; if(LOCK_LAYER_TO_VIEW){ LAYER_MAX_DIST = VIEW_FAR; ctlLayerMax.value = LAYER_MAX_DIST; vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0);} });
ctlViewFar.addEventListener('input', ()=>{ if(LOCK_LAYER_TO_VIEW){ LAYER_MAX_DIST = VIEW_FAR; ctlLayerMax.value = LAYER_MAX_DIST; vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0);} });
// Fog controls removed

// Procedural sky controls
if(ctlStarsSky){ ctlStarsSky.addEventListener('change', ()=>{ if(typeof setProceduralSky==='function') setProceduralSky(ctlStarsSky.checked); }); }
if(ctlMoonOnSky){ ctlMoonOnSky.addEventListener('change', ()=>{ if(typeof configureProceduralSky==='function') configureProceduralSky({ moonOn: ctlMoonOnSky.checked }); }); }
if(ctlStarDensity){ ctlStarDensity.addEventListener('input', ()=>{ vStarDensity.textContent = ctlStarDensity.value; if(typeof configureProceduralSky==='function') configureProceduralSky({ starDensity: Number(ctlStarDensity.value) }); }); }

// ASCII controls
if(ctlAsciiOn){ ctlAsciiOn.addEventListener('change', ()=>{ ASCII_ON = ctlAsciiOn.checked; if(ASCII_ON){ if(typeof postEnsureSceneTarget==='function') postEnsureSceneTarget(gl, canvas.width, canvas.height); } }); }
if(ctlAsciiCell){ ctlAsciiCell.addEventListener('input', ()=>{ ASCII_CELL_PX = Number(ctlAsciiCell.value); if(vAsciiCell) vAsciiCell.textContent = ASCII_CELL_PX.toFixed(0); }); }
if(ctlAsciiBright){ ctlAsciiBright.addEventListener('input', ()=>{ ASCII_BRIGHTNESS = Number(ctlAsciiBright.value); if(vAsciiBright) vAsciiBright.textContent = ASCII_BRIGHTNESS.toFixed(2); }); }
if(ctlAsciiDark){ ctlAsciiDark.addEventListener('input', ()=>{ ASCII_BG_DARKEN = Number(ctlAsciiDark.value); if(vAsciiDark) vAsciiDark.textContent = ASCII_BG_DARKEN.toFixed(2); }); }

  // Freeze background toggle and start band selector (UI minimal: buttons)
  const freezeBtn = document.createElement('span'); freezeBtn.className='btn'; freezeBtn.style.marginLeft='6px'; freezeBtn.textContent='Freeze BG';
  const freezeBandInc = document.createElement('span'); freezeBandInc.className='btn'; freezeBandInc.style.marginLeft='6px'; freezeBandInc.textContent='BG Start++';
  const freezeBandDec = document.createElement('span'); freezeBandDec.className='btn'; freezeBandDec.style.marginLeft='6px'; freezeBandDec.textContent='BG Start--';
  uiRoot.appendChild(freezeBtn); uiRoot.appendChild(freezeBandDec); uiRoot.appendChild(freezeBandInc);
  let frozenStart = -1;
  function applyFrozen(){ if(typeof postSetFrozenStartBand==='function') postSetFrozenStartBand(frozenStart); }
  freezeBtn.onclick = ()=>{ frozenStart = (frozenStart<0) ? 10 : -1; applyFrozen(); };
  freezeBandInc.onclick = ()=>{ if(frozenStart<LAYERS-1){ frozenStart++; applyFrozen(); } };
  freezeBandDec.onclick = ()=>{ if(frozenStart>-1){ frozenStart--; applyFrozen(); } };

function compile(type,src){
  const s = gl.createShader(type);
  gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s)); throw new Error('shader compile');
  }
  return s;
}
function link(vs,fs){
  const p = gl.createProgram();
  gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p)); throw new Error('link');
  }
  return p;
}

/*** ---------- Shaders ---------- ***/
// We pass world position + flat color. Fragment bins distance into 14 layers and applies
// a screen-space “brush/pixel” effect (consistent size regardless of distance).
const VS = `#version 300 es
layout(location=0) in vec3 a_pos;
layout(location=1) in vec3 a_col;
layout(location=2) in vec3 a_norm;

uniform mat4 u_proj, u_view, u_model;

out vec3 v_col;
out vec3 v_world;
out vec3 v_norm;
out vec2 v_worldXZ; // world-space XZ for checker pattern
out float v_eyeZ;   // positive view-space depth

void main(){
  vec4 world = u_model * vec4(a_pos,1.0);
  v_world = world.xyz;
  v_col = a_col;
  // Model is identity, but keep path for clarity/extension
  mat3 normalMat = mat3(u_model);
  v_norm = normalize(normalMat * a_norm);
  v_worldXZ = world.xz;
  vec4 viewPos = u_view * world;     // view space
  v_eyeZ = -viewPos.z;               // positive forward
  gl_Position = u_proj * viewPos;
}
`;

const FS = `#version 300 es
precision highp float;

in vec3 v_col;
in vec3 v_world;
in vec3 v_norm;
in vec2 v_worldXZ;
in float v_eyeZ;

out vec4 o_color;

uniform vec3  u_camPos;
uniform float u_maxDist;
uniform int   u_layers;
uniform vec2  u_res;
  uniform vec2  u_outRes; // final on-screen composite region size in pixels
uniform float u_time;
uniform float u_strokePx;
uniform float u_variation;
uniform vec3  u_lightDir;   // direction TO light (world space)
uniform vec3  u_lightColor; // light RGB
uniform float u_ambient;    // ambient term
uniform float u_checkerSize; // world units per cell
uniform float u_checkerAlpha; // opacity of checker overlay
  uniform bool  u_checkerScreen; // when true, checker grid is screen-space per band
uniform int   u_activeBand; // -1 = render all; 0..13 = only that band (others discard)
uniform int   u_renderMode; // 0 = terrain stylized, 1 = model (solid shading)
// Outline controls
uniform bool  u_outlineOn;      // enable black edge outlines
uniform float u_outlineScale;   // scales edge sensitivity
uniform float u_outlineIntensity; // 0..1 how strongly to darken to black on edges
uniform int   u_outlineBand;    // which band index to outline (0 = nearest)
// fog uniforms removed (disabled)

// Debug palette for 14 distance layers (index 0 = nearest, 13 = furthest)
const vec3 PALETTE[14] = vec3[14](
  vec3(0.02, 0.06, 0.02), // 1  black tinted green
  vec3(0.77, 0.60, 0.42), // 2  dark tan
  vec3(0.90, 0.78, 0.61), // 3  light tan
  vec3(0.55, 0.23, 0.16), // 4  reddish brown
  vec3(0.55, 0.43, 0.24), // 5  greenish brown
  vec3(0.30, 0.69, 0.31), // 6  green
  vec3(0.80, 0.86, 0.22), // 7  greenish yellow
  vec3(0.21, 0.47, 0.23), // 8  dark green
  vec3(0.50, 1.00, 0.83), // 9  light blue green
  vec3(0.00, 0.65, 0.65), // 10 medium blue green
  vec3(0.00, 0.30, 0.30), // 11 dark blue green
  vec3(0.78, 0.49, 1.00), // 12 light purple
  vec3(0.42, 0.00, 0.66), // 13 medium purple
  vec3(0.16, 0.00, 0.33)  // 14 dark purple
);

// hash helpers
float hash11(float p){ return fract(sin(p*127.1)*43758.5453); }
float hash21(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }

// quantize into N bands (0..N-1) based on distance
// Ensure the last band (N-1) contains everything at/above maxD
float bandIndex(float d, float maxD, float N){
  float eps = 1e-4;
  float denom = max(maxD / N, eps);
  float clamped = min(d, maxD - eps); // push values at/above maxD into final bin
  float idx = floor(clamped / denom);
  return clamp(idx, 0.0, N - 1.0);
}

  void main(){
  // distance from camera in world space (rotation-invariant)
  float d = distance(v_world, u_camPos);
  float idx = bandIndex(d, u_maxDist, float(u_layers));

  // Band mask: when u_activeBand >= 0, only draw that band
  if(u_activeBand >= 0 && int(idx) != u_activeBand){
    discard;
  }

  // Simple PBR-ish shading path for models: baseColor, metallic, roughness
  if(u_renderMode == 1){
    vec3 n = normalize(v_norm);
    vec3 V = normalize(u_camPos - v_world);
    vec3 L = normalize(-u_lightDir);
    vec3 H = normalize(V+L);
    // Uniforms are packed via u_lightColor for base RGB and metallic in blue; roughness via u_ambient
    float metallic = clamp(u_lightColor.z, 0.0, 1.0);
    float roughness = clamp(u_ambient, 0.04, 1.0);
    vec3 baseColor = vec3(u_lightColor.x, u_lightColor.y, 1.0);
    float NdotL = max(dot(n,L), 0.0);
    float NdotV = max(dot(n,V), 0.0);
    float NdotH = max(dot(n,H), 0.0);
    float VdotH = max(dot(V,H), 0.0);
    float a = roughness*roughness;
    float a2 = a*a;
    float denom = (NdotH*NdotH*(a2-1.0)+1.0);
    float D = a2 / max(3.14159 * denom*denom, 1e-4);
    float k = (roughness+1.0); k = (k*k)/8.0;
    float Gv = NdotV / max(NdotV*(1.0-k)+k, 1e-4);
    float Gl = NdotL / max(NdotL*(1.0-k)+k, 1e-4);
    float G = Gv * Gl;
    vec3 F0 = mix(vec3(0.04), baseColor, metallic);
    vec3 F = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);
    vec3 spec = (D * G) * F / max(4.0 * NdotV * NdotL, 1e-4);
    vec3 kd = (1.0 - F) * (1.0 - metallic);
    vec3 diffuse = kd * baseColor / 3.14159;
    vec3 color = (diffuse + spec) * NdotL;
    o_color = vec4(color, 1.0);
    return;
  }

  // Base color from palette by distance layer (slightly brighter palette)
  vec3 layerColor = min(PALETTE[int(idx)] * 1.25, vec3(1.0));
  // Brighter mid-day lighting
  float lambert = max(dot(normalize(v_norm), normalize(-u_lightDir)), 0.0);
  float lightIntensity = clamp(u_ambient + lambert * 1.2, 0.0, 2.0);
  vec3 color = layerColor * lightIntensity * u_lightColor;

  // Checkerboard: either world-space or screen-space per band
  float checker;
  if(u_checkerScreen){
    // Screen-space, band-local grid: stable square cells regardless of framebuffer size
    // Use u_res (current render target) for coordinate system so pixels are square
    float cell = max(1.0, u_checkerSize);
    vec2 bandOffset = vec2(hash11(idx*13.7), hash11(idx*7.9)) * cell;
    vec2 gid = floor((gl_FragCoord.xy + bandOffset));
    // Divide separately on x and y by the same 'cell' to ensure squares
    gid.x = floor((gl_FragCoord.x + bandOffset.x) / cell);
    gid.y = floor((gl_FragCoord.y + bandOffset.y) / cell);
    checker = mod(gid.x + gid.y, 2.0);
  } else {
    // World-space grid
    float cx = floor(v_worldXZ.x / max(1.0, u_checkerSize));
    float cz = floor(v_worldXZ.y / max(1.0, u_checkerSize));
    checker = mod(cx + cz, 2.0);
  }
  vec3 checkerCol = mix(vec3(0.0), vec3(1.0), checker);
  // Overlay checker onto color
  color = mix(color, checkerCol, clamp(u_checkerAlpha, 0.0, 1.0));

  // Screen-space “pseudo-pixels”: overlapping, rotated squares with ~5% size jitter
  vec2 uv = gl_FragCoord.xy;       // screen space
  float base = u_strokePx;
  // small per-layer variation (±5%) so bands don't align too perfectly
  float jitter = 1.0 + (u_variation * (hash11(idx+1.234) * 2.0 - 1.0));
  float cell = base * jitter;

  // snap to grid
  vec2 cellId = floor(uv / cell);
  vec2 cellCenter = (cellId + 0.5) * cell;

  // per-cell randoms
  float r = hash21(cellId + vec2(idx*13.1, idx*7.7));

  // slight drift per-layer to avoid moiré when moving
  vec2 drift = vec2(sin((idx+1.0)*0.7 + u_time*0.1), cos((idx+1.0)*0.9 + u_time*0.08)) * (cell*0.08);

  // rotate square slightly per-cell
  float ang = (r - 0.5) * 0.35; // ~±20°
  mat2 rot = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));
  vec2 p = rot * (uv - (cellCenter + drift));

  // half-size larger than cell/2 so squares overlap
  float halfSize = 0.65 * cell;
  // extra tiny jitter to keep sizes uneven (~±2%) layered on top of ±5%
  halfSize *= 0.98 + 0.04 * hash21(cellId + vec2(19.7, 3.1));

  // square SDF using L∞ norm, softened edges
  float edge = max(abs(p.x), abs(p.y)) / halfSize;
  float mask = smoothstep(1.05, 0.85, edge);

  // composite: each layer paints only inside its blotch cells. We intentionally
  // keep coverage below 1.0 (especially for near bands) so deeper bands remain visible.
  vec3 paper = vec3(0.06,0.07,0.08);
  vec3 painted = mix(color, color*0.85, 0.3 + 0.2*r); // slight variation per stamp

  // fake multi-stroke feel by modulating with a second threshold
  float ring = smoothstep(0.95, 0.7, edge);
  painted *= (0.9 + 0.1*ring);

  // depth fade per layer for separation
  // No fog: final color is just painted
  vec3 col = painted;

  // apply mask as coverage and alpha; modulate by band index so nearer bands
  // remain more porous and do not fully cover distant bands
  float coverage = clamp(mask, 0.0, 1.0);
  float tBand = (u_layers > 1) ? (idx / float(u_layers - 1)) : 0.0; // 0 near, 1 far
  float bandCoverageScale = mix(0.42, 0.88, tBand); // near ~0.42, far ~0.88
  coverage *= bandCoverageScale;
  // Screen-space edge outlines based on normal/depth variations
  if(u_outlineOn && int(idx) == u_outlineBand){
    // Use derivatives to detect discontinuities that suggest geometric edges
    vec3 n = normalize(v_norm);
    float nEdge = length(fwidth(n));                 // normal variation across pixel
    float zEdge = fwidth(v_eyeZ / max(u_maxDist, 1e-3)); // normalized depth variation
    // Emphasize cliff tops via slope change (variation of |n.y|)
    float slope = 1.0 - abs(n.y);                    // 0 flat, 1 vertical
    float slopeChange = fwidth(slope);
    // Rim term: surfaces at grazing view angles, gated by slope so it targets ledges
    vec3 V = normalize(u_camPos - v_world);
    float rim = smoothstep(0.65, 0.92, 1.0 - abs(dot(n, V)));
    rim *= smoothstep(0.25, 0.55, slope);
    // Weighted sum; slope change and rim help catch ridge/ledge boundaries
    float edge = (nEdge * 1.0 + zEdge * 0.5 + slopeChange * 2.0 + rim * 1.2) * u_outlineScale;
    // Convert into a 0..1 mask where higher = stronger edge
    // Adaptive threshold: be a bit more permissive when stroke size is small
    float t0 = 0.045; // base low threshold
    float t1 = 0.16;  // base high threshold
    float edgeMask = smoothstep(t0, t1, edge);
    // Darken towards black on edges before applying coverage
    col = mix(col, vec3(0.0), clamp(edgeMask * u_outlineIntensity, 0.0, 1.0));
  }
  o_color = vec4(mix(paper, col, coverage), coverage);
}
`;

/*** ---------- Program & Buffers ---------- ***/
const vs = compile(gl.VERTEX_SHADER, VS);
const fs = compile(gl.FRAGMENT_SHADER, FS);
const prog = link(vs, fs);
gl.useProgram(prog);

const loc = {
  a_pos: 0, a_col: 1, a_norm: 2,
  u_proj: gl.getUniformLocation(prog,'u_proj'),
  u_view: gl.getUniformLocation(prog,'u_view'),
  u_model: gl.getUniformLocation(prog,'u_model'),
  u_camPos: gl.getUniformLocation(prog,'u_camPos'),
  u_maxDist: gl.getUniformLocation(prog,'u_maxDist'),
  u_layers: gl.getUniformLocation(prog,'u_layers'),
  u_res: gl.getUniformLocation(prog,'u_res'),
    u_outRes: gl.getUniformLocation(prog,'u_outRes'),
  u_time: gl.getUniformLocation(prog,'u_time'),
  u_strokePx: gl.getUniformLocation(prog,'u_strokePx'),
  u_variation: gl.getUniformLocation(prog,'u_variation'),
  u_lightDir: gl.getUniformLocation(prog,'u_lightDir'),
  u_lightColor: gl.getUniformLocation(prog,'u_lightColor'),
  u_ambient: gl.getUniformLocation(prog,'u_ambient'),
  u_checkerSize: gl.getUniformLocation(prog,'u_checkerSize'),
  u_checkerAlpha: gl.getUniformLocation(prog,'u_checkerAlpha'),
  u_checkerScreen: gl.getUniformLocation(prog,'u_checkerScreen'),
  u_activeBand: gl.getUniformLocation(prog,'u_activeBand'),
  u_renderMode: gl.getUniformLocation(prog,'u_renderMode'),
  // outline uniforms
  u_outlineOn: gl.getUniformLocation(prog,'u_outlineOn'),
  u_outlineScale: gl.getUniformLocation(prog,'u_outlineScale'),
  u_outlineIntensity: gl.getUniformLocation(prog,'u_outlineIntensity'),
  u_outlineBand: gl.getUniformLocation(prog,'u_outlineBand'),
};

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const vbo = gl.createBuffer();
const ibo = gl.createBuffer();
let terrainAttribsSet = false;

// legacy counter (unused; terrain.js provides counts)
let indexCount = 0;
let activeBand = -1; // -1 = all

// Offscreen targets moved to postcompose.js

// Terrain sampling moved to terrain.js

/*** ---------- Heightmap -> Terrain Mesh ---------- ***/
// Implemented in terrain.js

/*** ---------- Camera / Controls ---------- ***/
let camPos = {x:0, y:60, z:-SIZE*0.8};
let yaw = 0, pitch = 0; // maintained from camera target each frame
// Airplane state
let plane = { pos:{x:0,y:0,z:0}, yaw:0, pitch:0, roll:0, speed:0, throttle:0, onGround:true };
// Diorama card tilt (radians)
let cardTiltX = 0, cardTiltY = 0;
let cardTiltXTarget = 0, cardTiltYTarget = 0;
// Sprint/stamina state
let stamina = 1.0;             // unused (legacy UI)
let sprintHoldTime = 0.0;
let isSprinting = false;
// Player model (glTF)
let playerModel = { ready:false, drawables:[], bounds:null, scale:1 };
// Player entity state: world transform independent of camera
let playerEntity = { initialized:false, pos:{x:0,y:0,z:0}, yaw:0 };

const keys = {};
addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='r'||e.key==='R') recenter(); if(e.key==='h'||e.key==='H') setUiHidden(!uiHidden); });
addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

// Debug helper: place plane in front of camera (P)
function placePlayerInFront(){
  const f = getDir();
  playerEntity.pos.x = camPos.x + f.x * 30.0;
  playerEntity.pos.z = camPos.z + f.z * 30.0;
  playerEntity.pos.y = sampleTerrainHeightAtWorld(playerEntity.pos.x, playerEntity.pos.z, SIZE) + 10.0;
  playerEntity.yaw = yaw + PLAYER_YAW_OFFSET;
  playerEntity.initialized = true;
}
addEventListener('keydown', e=>{
  if(e.key==='p' || e.key==='P'){ placePlayerInFront(); }
});

function recenter(){
  // Place plane at world origin on ground, facing +Z
  const gy = sampleTerrainHeightAtWorld(0, 0, SIZE);
  plane.pos = { x: 0, y: gy + PLANE_CLEARANCE, z: 0 };
  plane.yaw = 0;
  plane.pitch = 0;
  plane.roll = 0;
  plane.speed = 0;
  plane.throttle = 0;
  plane.onGround = true;
  // Camera behind plane
  const fwd = forwardFromEuler(plane.yaw, plane.pitch);
  const basis = basisFromEuler(plane.yaw, plane.pitch, plane.roll);
  const up = upFromBasis(basis);
  camPos = {
    x: plane.pos.x - fwd.x * CAMERA_FOLLOW_DIST + up.x * CAMERA_FOLLOW_HEIGHT,
    y: plane.pos.y - fwd.y * CAMERA_FOLLOW_DIST + up.y * CAMERA_FOLLOW_HEIGHT,
    z: plane.pos.z - fwd.z * CAMERA_FOLLOW_DIST + up.z * CAMERA_FOLLOW_HEIGHT,
  };
  // Sync camera angles to look at plane
  const toTarget = { x: plane.pos.x - camPos.x, y: plane.pos.y - camPos.y, z: plane.pos.z - camPos.z };
  const l = Math.hypot(toTarget.x, toTarget.y, toTarget.z) || 1;
  const dir = { x: toTarget.x/l, y: toTarget.y/l, z: toTarget.z/l };
  yaw = Math.atan2(dir.x, -dir.z);
  pitch = Math.asin(-dir.y);
  // Player entity mirrors plane for renderer
  playerEntity.pos = { x: plane.pos.x, y: plane.pos.y, z: plane.pos.z };
  playerEntity.yaw = plane.yaw + PLAYER_YAW_OFFSET;
  playerEntity.initialized = true;
}
recenterBtn.onclick = recenter;

canvas.addEventListener('click', ()=> canvas.requestPointerLock());
const MOUSE_LOOK_ENABLED = false; // disabled for airplane mode
addEventListener('mousemove', e=>{
  if(MOUSE_LOOK_ENABLED && document.pointerLockElement === canvas){
    yaw += e.movementX * LOOK_SENS;
    pitch += e.movementY * LOOK_SENS;
    pitch = Math.max(-1.2, Math.min(1.2, pitch));
  }
});

function getDir(){
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  const cp = Math.cos(pitch), sp = Math.sin(pitch);
  // forward in XZ with pitch applied
  return {
    x: sy * cp,
    y: -sp,
    z: -cy * cp
  };
}
function getRight(){
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  return { x: cy, y: 0, z: sy };
}

function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function lerpAngle(a, b, t){ let d = ((b - a + Math.PI) % (2*Math.PI)) - Math.PI; return a + d * t; }
function basisFromEuler(yawR, pitchR, rollR){
  const cy=Math.cos(yawR), sy=Math.sin(yawR);
  const cp=Math.cos(pitchR), sp=Math.sin(pitchR);
  const cz=Math.cos(rollR),  sz=Math.sin(rollR);
  // R = Ry * Rx * Rz
  // Columns are transformed basis vectors
  // Start with Rz
  const Xz = {x:cz, y:sz, z:0};
  const Yz = {x:-sz, y:cz, z:0};
  const Zz = {x:0, y:0, z:1};
  // Apply Rx
  function rx(v){ return { x: v.x, y: v.y*cp - v.z*sp, z: v.y*sp + v.z*cp }; }
  const Xxz = rx(Xz), Yxz = rx(Yz), Zxz = rx(Zz);
  // Apply Ry
  function ry(v){ return { x: v.x*cy + v.z*sy, y: v.y, z: -v.x*sy + v.z*cy }; }
  const X = ry(Xxz), Y = ry(Yxz), Z = ry(Zxz);
  return { X, Y, Z };
}
function modelMatrixFromBasis(pos, basis, scale){
  const sc = scale;
  return new Float32Array([
    basis.X.x*sc, basis.X.y*sc, basis.X.z*sc, 0,
    basis.Y.x*sc, basis.Y.y*sc, basis.Y.z*sc, 0,
    basis.Z.x*sc, basis.Z.y*sc, basis.Z.z*sc, 0,
    pos.x,        pos.y,        pos.z,        1
  ]);
}
// 3x3 alignment matrix that maps model-local axes to our world axes; default identity
let MODEL_ALIGN = [1,0,0, 0,1,0, 0,0,1]; // column-major 3x3
function mulBasisByMat3(b, m){
  // m is 3x3 column-major
  function col(i){ return { x:m[i*3+0], y:m[i*3+1], z:m[i*3+2] }; }
  const c0 = col(0), c1 = col(1), c2 = col(2);
  function comb(c){ return { x: b.X.x*c.x + b.Y.x*c.y + b.Z.x*c.z,
                             y: b.X.y*c.x + b.Y.y*c.y + b.Z.y*c.z,
                             z: b.X.z*c.x + b.Y.z*c.y + b.Z.z*c.z }; }
  const X = normalize3(comb(c0));
  const Y = normalize3(comb(c1));
  const Z = normalize3(comb(c2));
  return { X, Y, Z };
}
function getPlaneModelMatrix(){
  // Stable basis from forward (yaw+pitch) and world up; then apply bank (roll) and local axis fixes.
  const fwd0 = normalize3(forwardFromEulerPlane(plane.yaw, plane.pitch));
  let right0 = cross3({x:0,y:1,z:0}, fwd0);
  const rl = Math.hypot(right0.x, right0.y, right0.z);
  if(rl < 1e-4){ right0 = {x:1,y:0,z:0}; }
  right0 = normalize3(right0);
  let up0 = normalize3(cross3(fwd0, right0));
  // Apply roll around forward
  const bank = plane.roll;
  const right1 = rotateAroundAxis(right0, fwd0, bank + PLAYER_MODEL_ROLL_FIX);
  let up1 = normalize3(cross3(fwd0, right1));
  // Apply pitch fix around new right
  const fwd2 = rotateAroundAxis(fwd0, right1, PLAYER_MODEL_PITCH_FIX);
  up1 = normalize3(cross3(fwd2, right1));
  // Apply yaw fix around up
  const right2 = rotateAroundAxis(right1, up1, PLAYER_MODEL_YAW_FIX + PLAYER_YAW_OFFSET);
  const fwd3 = normalize3(cross3(right2, up1));
  const sc = playerModel.scale * 0.6;
  const bodyBasis = { X: right2, Y: up1, Z: fwd3 };
  const alignedBasis = mulBasisByMat3(bodyBasis, MODEL_ALIGN);
  return modelMatrixFromBasis(plane.pos, alignedBasis, sc);
}
function forwardFromEuler(yawR, pitchR){
  const cy=Math.cos(yawR), sy=Math.sin(yawR);
  const cp=Math.cos(pitchR), sp=Math.sin(pitchR);
  return { x: sy*cp, y: -sp, z: -cy*cp };
}
// For airplane physics, positive pitch should raise the nose and produce positive vertical component
function forwardFromEulerPlane(yawR, pitchR){
  const cy=Math.cos(yawR), sy=Math.sin(yawR);
  const cp=Math.cos(pitchR), sp=Math.sin(pitchR);
  return { x: sy*cp, y: sp, z: -cy*cp };
}
function upFromBasis(basis){ return { x: basis.Y.x, y: basis.Y.y, z: basis.Y.z }; }
function normalize3(v){ const l=Math.hypot(v.x,v.y,v.z)||1; return {x:v.x/l,y:v.y/l,z:v.z/l}; }
function cross3(a,b){ return { x: a.y*b.z - a.z*b.y, y: a.z*b.x - a.x*b.z, z: a.x*b.y - a.y*b.x }; }
function dot3(a,b){ return a.x*b.x + a.y*b.y + a.z*b.z; }
function rotateAroundAxis(v, axis, angle){
  const u = normalize3(axis);
  const c = Math.cos(angle), s = Math.sin(angle);
  const dot = dot3(u, v);
  return {
    x: v.x*c + (u.y*v.z - u.z*v.y)*s + u.x*dot*(1-c),
    y: v.y*c + (u.z*v.x - u.x*v.z)*s + u.y*dot*(1-c),
    z: v.z*c + (u.x*v.y - u.y*v.x)*s + u.z*dot*(1-c),
  };
}

function tick(dt){
  // --- Inputs ---
  // Throttle
  if(keys['w']) plane.throttle += 0.8*dt;
  if(keys['s']) plane.throttle -= 0.8*dt;
  plane.throttle = clamp(plane.throttle, 0, 1);
  const afterburner = keys['shift'] === true;
  const thrust = THRUST_BASE * plane.throttle * (afterburner ? AFTERBURNER_MULT : 1.0);
  // Pitch
  if(keys['arrowdown']) plane.pitch += PITCH_RATE * dt; // nose up
  if(keys['arrowup'])   plane.pitch -= PITCH_RATE * dt; // nose down
  plane.pitch = clamp(plane.pitch, -MAX_PITCH, MAX_PITCH);
  // Roll with auto-return when no input
  const rollInput = (keys['d']? 1 : 0) + (keys['a']? -1 : 0);
  if(rollInput !== 0){
    plane.roll += rollInput * ROLL_RATE * dt;
  } else {
    // spring back to level
    const k = Math.min(1.0, ROLL_RETURN_RATE * dt);
    plane.roll += (-plane.roll) * k;
  }
  plane.roll = clamp(plane.roll, -MAX_ROLL, MAX_ROLL);

  // --- Physics ---
  // Speed integration with drag
  const drag = DRAG_COEFF * plane.speed * plane.speed;
  plane.speed += (thrust - drag) * dt;
  plane.speed = clamp(plane.speed, 0, MAX_SPEED);

  // Banked turning (yaw induced by roll). Ensure a base yaw rate even at low speeds.
  const speedNorm = clamp(plane.speed / MAX_SPEED, 0, 1);
  const turnRate = MIN_TURN_RATE + BANK_TURN_RATE * speedNorm; // rad/sec at sin(roll)=1
  plane.yaw += Math.sin(plane.roll) * turnRate * dt;

  // Forward vector in world (plane orientation drives movement; camera is passive)
  const fwd = forwardFromEulerPlane(plane.yaw, plane.pitch);
  // Move
  plane.pos.x += fwd.x * plane.speed * dt;
  plane.pos.z += fwd.z * plane.speed * dt;
  // Altitude and takeoff/landing
  const groundYBase = sampleTerrainHeightAtWorld(plane.pos.x, plane.pos.z, SIZE);
  const groundY = WAVE_ON ? (groundYBase + Math.sin(gTimeSec * WAVE_SPEED) * WAVE_AMP) : groundYBase;
  if(plane.onGround){
    plane.pos.y = groundY + PLANE_CLEARANCE;
    // Allow takeoff once fast enough and pitching up
    if(plane.speed > TAKEOFF_SPEED && plane.pitch > 0.08){ plane.onGround = false; }
    // Auto-damp roll while on ground
    plane.roll *= Math.max(0, 1 - 4.0*dt);
    } else {
    // Free flight: climb/sink via pitch; mild gravity sink
    plane.pos.y += fwd.y * plane.speed * dt;
    plane.pos.y -= GRAV * 0.05 * dt;
    // Hard ground collision
    const minY = groundY + PLANE_CLEARANCE;
    if(plane.pos.y <= minY){
      plane.pos.y = minY;
      plane.onGround = true;
      // frictional speed bleed on touchdown
      plane.speed *= 0.85;
      // flatten pitch on touchdown over time
      plane.pitch *= 0.5;
    }
  }

  // --- Camera follow (spring) ---
  // Keep the camera behind the plane relative to plane forward, with a constant world-up height offset.
  const camTarget = {
    x: plane.pos.x - fwd.x * CAMERA_FOLLOW_DIST,
    y: plane.pos.y + CAMERA_FOLLOW_HEIGHT,
    z: plane.pos.z - fwd.z * CAMERA_FOLLOW_DIST,
  };
  // Hard lock X/Z behind the plane; only smooth vertical for comfort
  const tY = 1 - Math.exp(-CAMERA_SPRING * dt);
  camPos.x = camTarget.x;
  camPos.z = camTarget.z;
  camPos.y += (camTarget.y - camPos.y) * tY;

  // Update player entity for renderer
  playerEntity.pos.x = plane.pos.x;
  playerEntity.pos.y = plane.pos.y;
  playerEntity.pos.z = plane.pos.z;
  playerEntity.yaw = plane.yaw + PLAYER_YAW_OFFSET;
  playerEntity.initialized = true;

  // Derive camera yaw/pitch toward a point ahead of the plane so the camera stays behind it
  const lookAhead = 120.0;
  const lookPoint = { x: plane.pos.x + fwd.x * lookAhead, y: plane.pos.y + fwd.y * lookAhead * 0.15, z: plane.pos.z + fwd.z * lookAhead };
  const toLook = normalize3({ x: lookPoint.x - camPos.x, y: lookPoint.y - camPos.y, z: lookPoint.z - camPos.z });
  const targetYaw = Math.atan2(toLook.x, -toLook.z);
  const targetPitch = Math.asin(-toLook.y);
  // Directly set orientation to minimize orbital lag
  yaw = targetYaw;
  pitch = targetPitch;
}

/*** ---------- Matrices ---------- ***/
function perspective(fovy, aspect, near, far){
  const f = 1/Math.tan(fovy/2), nf = 1/(near-far);
  return new Float32Array([
    f/aspect,0,0,0,
    0,f,0,0,
    0,0,(far+near)*nf,-1,
    0,0,(2*far*near)*nf,0
  ]);
}
function lookAt(eye, center, up){
  const zx = eye.x-center.x, zy = eye.y-center.y, zz = eye.z-center.z;
  const zl = Math.hypot(zx,zy,zz);
  const zxN=zx/zl, zyN=zy/zl, zzN=zz/ zl;

  const xx = up.y*zzN - up.z*zyN;
  const xy = up.z*zxN - up.x*zzN;
  const xz = up.x*zyN - up.y*zxN;
  const xl = Math.hypot(xx,xy,xz);
  const xNx=xx/xl, xNy=xy/xl, xNz=xz/xl;

  const yx = zyN*xNz - zzN*xNy;
  const yy = zzN*xNx - zxN*xNz;
  const yz = zxN*xNy - zyN*xNx;

  return new Float32Array([
    xNx, yx, zxN, 0,
    xNy, yy, zyN, 0,
    xNz, yz, zzN, 0,
    -(xNx*eye.x + xNy*eye.y + xNz*eye.z),
    -(yx*eye.x + yy*eye.y + yz*eye.z),
    -(zxN*eye.x + zyN*eye.y + zzN*eye.z),
    1
  ]);
}

/*** ---------- Render Loop ---------- ***/
let last = performance.now();
let lastFrameTime = 0;
let gTimeSec = 0; // global seconds timestamp for effects physics
function frame(t){
  // FPS cap: skip frames to meet target cadence
  if(FPS_CAP_ENABLED){
    const minDelta = 1000 / FPS_CAP;
    if(t - lastFrameTime < minDelta){ requestAnimationFrame(frame); return; }
    lastFrameTime = t;
  }
  const dt = Math.min(0.033, (t-last)/1000); last = t;
  gTimeSec = t*0.001;
  tick(dt);
  updateStatus();
  // no diorama tilt
  cardTiltX = 0; cardTiltY = 0; cardTiltXTarget = 0; cardTiltYTarget = 0;

  const aspect = canvas.width / canvas.height;
  const proj = perspective(FOVY, aspect, 0.1, VIEW_FAR);
  const f = getDir();
  const center = {x: camPos.x + f.x, y: camPos.y + f.y, z: camPos.z + f.z};
  const view = lookAt(camPos, center, {x:0,y:1,z:0});
  const model = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);

  gl.useProgram(prog);
  gl.uniformMatrix4fv(loc.u_proj,false,proj);
  gl.uniformMatrix4fv(loc.u_view,false,view);
  gl.uniformMatrix4fv(loc.u_model,false,model);
  gl.uniform3f(loc.u_camPos, camPos.x, camPos.y, camPos.z);
  gl.uniform1f(loc.u_maxDist, LAYER_MAX_DIST);
  gl.uniform1i(loc.u_layers, LAYERS);
  // u_res/u_outRes will be updated per-pass in the band render and comp steps
  gl.uniform1f(loc.u_time, t*0.001);
  gl.uniform1f(loc.u_strokePx, STROKE_PX);
  gl.uniform1f(loc.u_variation, VARIATION);
  // we will set activeBand per-pass below
  // Lighting uniforms
  const lightDir = normalizeVec3([-0.6, -1.0, -0.4]); // coming from above-left
  gl.uniform3f(loc.u_lightDir, lightDir[0], lightDir[1], lightDir[2]);
  gl.uniform3f(loc.u_lightColor, 1.25, 1.25, 1.25);
  gl.uniform1f(loc.u_ambient, 1.15);
  // Outline uniforms
  gl.uniform1i(loc.u_outlineOn, OUTLINE_ON ? 1 : 0);
  gl.uniform1f(loc.u_outlineScale, OUTLINE_SCALE);
  gl.uniform1f(loc.u_outlineIntensity, OUTLINE_INTENSITY);
  gl.uniform1i(loc.u_outlineBand, OUTLINE_BAND);
  // Checker uniforms
  gl.uniform1f(loc.u_checkerSize, CHECKER_SIZE);
  gl.uniform1f(loc.u_checkerAlpha, CHECKER_ALPHA);
  gl.uniform1i(loc.u_checkerScreen, CHECKER_SCREEN ? 1 : 0);
  gl.uniform1i(loc.u_renderMode, 0);

  // 1) Render each band to its texture (draw multiple wrapped tiles in a 3x3 grid)
  gl.bindVertexArray(vao);
  // Bind terrain buffers from terrain module (vbo/ibo already filled)
  if(typeof bindTerrainBuffers==='function') bindTerrainBuffers(gl);
  // Use actual canvas dimensions for square screen-space checkers
  const outW = canvas.width, outH = canvas.height;
  const passesToRender = (activeBand>=0) ? 1 : LAYER_PASSES;
  for(let p=0;p<passesToRender;p++){
    const bandIndexToRender = (activeBand>=0) ? activeBand : p;
    if(typeof postBindLayerFbo==='function') postBindLayerFbo(gl, bandIndexToRender);
    const rw = Math.max(1, Math.floor(canvas.width * RES_SCALE));
    const rh = Math.max(1, Math.floor(canvas.height * RES_SCALE));
    gl.viewport(0,0,rw,rh);
    gl.enable(gl.DEPTH_TEST);
    // If this band is frozen and already captured, do not clear or redraw
    const shouldRender = (typeof postShouldRenderBand==='function') ? postShouldRenderBand(bandIndexToRender) : true;
    if(!shouldRender){
      continue;
    }
    gl.clearColor(0.0,0.0,0.0,0.0);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    // Update per-target and output sizes for screen-space checkers
    gl.uniform2f(loc.u_res, rw, rh);
    gl.uniform2f(loc.u_outRes, outW, outH);
    gl.uniform1i(loc.u_activeBand, bandIndexToRender);
    const terrainIndexCount = (typeof getTerrainIndexCount==='function') ? getTerrainIndexCount() : indexCount;
    // draw 5x5 tiles anchored to the current camera tile so terrain follows the plane
    const translations = [-2,-1,0,1,2];
    const tileSpan = SIZE * 2.0;
    const baseX = Math.floor(camPos.x / tileSpan) * tileSpan;
    const baseZ = Math.floor(camPos.z / tileSpan) * tileSpan;
    for(let ox of translations){
      for(let oz of translations){
        const tx = baseX + ox * tileSpan;
        const tz = baseZ + oz * tileSpan;
        // Magic per-layer vertical wave offset
        let waveY = 0.0;
        if(WAVE_ON){
          const phase = WAVE_PHASE * bandIndexToRender;
          waveY = Math.sin((t*0.001)*WAVE_SPEED + phase) * WAVE_AMP;
        }
        const modelT = new Float32Array([
          1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          tx,waveY,tz,1
        ]);
        gl.uniformMatrix4fv(loc.u_model,false,modelT);
        gl.drawElements(gl.TRIANGLES, terrainIndexCount, gl.UNSIGNED_INT, 0);
      }
    }
    // Draw player model in this band without stylization, using independent player transform
    if(playerModel && playerModel.ready && playerEntity.initialized){
      const mPlayer = getPlaneModelMatrix();
      gl.uniformMatrix4fv(loc.u_model, false, mPlayer);
      gl.uniform1i(loc.u_renderMode, 1);
      gl.uniform1i(loc.u_activeBand, bandIndexToRender);
      for(const d of playerModel.drawables){
        gl.bindVertexArray(d.vao);
        gl.drawElements(d.mode, d.indexCount, d.indexType, d.indexOffsetBytes);
      }
      gl.uniformMatrix4fv(loc.u_model,false,model);
      gl.uniform1i(loc.u_renderMode, 0);
    } else {
      gl.uniformMatrix4fv(loc.u_model,false,model);
    }
    if(typeof postMarkBandRendered==='function') postMarkBandRendered(bandIndexToRender);
  }

  // 2) Composite to either scene FBO (ASCII) or default framebuffer
  if(ASCII_ON && typeof postEnsureSceneTarget==='function' && typeof postBindSceneFbo==='function'){
    postEnsureSceneTarget(gl, canvas.width, canvas.height);
    postBindSceneFbo(gl);
  } else {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0.0,0.0,0.0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  // Sky was previously drawn here, but we clear again below. We'll draw it after the clear.

  // Fill background with solid color; skip fullscreen composition
  // Keep target as set above (scene FBO or default)
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0.02,0.02,0.02,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // Draw sky first (daytime texture)
  if(typeof drawSkyBackground === 'function'){
    drawSkyBackground(gl, canvas.width / canvas.height, FOVY, getDir, canvas, SKYBOX_URL);
  }

  // Then compose terrain layers over the sky
  if(typeof postDrawLayersFullscreen === 'function'){
    postDrawLayersFullscreen(gl, canvas.width, canvas.height, LAYER_PASSES, activeBand);
  }

  // TEMP direct draw (bypasses offscreen band FBOs)
  if(DEBUG_DIRECT_DRAW){
    gl.useProgram(prog);
    gl.bindVertexArray(vao);
    if(typeof bindTerrainBuffers==='function') bindTerrainBuffers(gl);
    gl.enable(gl.DEPTH_TEST);
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.uniform2f(loc.u_res, canvas.width, canvas.height);
    gl.uniform2f(loc.u_outRes, canvas.width, canvas.height);
    gl.uniform1i(loc.u_activeBand, -1);
    gl.uniform1i(loc.u_renderMode, 0);
    const terrainIndexCount = (typeof getTerrainIndexCount==='function') ? getTerrainIndexCount() : indexCount;
    const translations = [-2,-1,0,1,2];
    const tileSpan = SIZE * 2.0;
    const baseX = Math.floor(camPos.x / tileSpan) * tileSpan;
    const baseZ = Math.floor(camPos.z / tileSpan) * tileSpan;
    for(let ox of translations){
      for(let oz of translations){
        const tx = baseX + ox * tileSpan;
        const tz = baseZ + oz * tileSpan;
        const modelT = new Float32Array([
          1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          tx,0,tz,1
        ]);
        gl.uniformMatrix4fv(loc.u_model,false,modelT);
        gl.drawElements(gl.TRIANGLES, terrainIndexCount, gl.UNSIGNED_INT, 0);
      }
    }
    // Draw player
    if(playerModel && playerModel.ready && playerEntity.initialized){
      const mPlayer = getPlaneModelMatrix();
      gl.uniformMatrix4fv(loc.u_model, false, mPlayer);
      gl.uniform1i(loc.u_renderMode, 1);
      for(const d of playerModel.drawables){
        gl.bindVertexArray(d.vao);
        if(d.material){
          const base = d.material.base; const metallic = d.material.metallic; const roughness = d.material.roughness;
          gl.uniform3f(loc.u_lightColor, base[0], base[1], metallic);
          gl.uniform1f(loc.u_ambient, Math.max(0.04, Math.min(1.0, roughness)));
        }
        gl.drawElements(d.mode, d.indexCount, d.indexType, d.indexOffsetBytes);
      }
      gl.uniform1i(loc.u_renderMode, 0);
    }
    gl.disable(gl.DEPTH_TEST);
  }

  // Card rendering disabled in single-canvas mode

  // Sync mirror overlay tilt with card tilt
  const mirror = document.getElementById('mirrorOverlay');
  if(mirror){ mirror.style.transform = `translate(-50%, -50%)`; }

  // If ASCII mode, present the ASCII post-process to screen now
  if(ASCII_ON && typeof postPresentAscii==='function'){
    postPresentAscii(gl, canvas.width, canvas.height, ASCII_CELL_PX, ASCII_BRIGHTNESS, ASCII_BG_DARKEN, ASCII_GAMMA);
  }

  requestAnimationFrame(frame);
}

// Composite function: draws each band texture as a fullscreen quad back-to-front
function drawLayersFullscreen(){
  ensureFullscreenGeom();
  // Simple throwaway shader for textured quad
  if(!quadProg){ initQuadProgram(); }
  gl.useProgram(quadProg);
  gl.bindVertexArray(fsVao);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
  // Enable alpha blending so empty pixels (alpha=0) in each band texture
  // do not overwrite previously drawn bands during composition
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  // draw far to near so near band overprints
  for(let i=LAYER_PASSES-1;i>=0;i--){
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, layerTexs[i]);
    gl.uniform1i(quadLoc.u_tex, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  gl.disable(gl.BLEND);
}

let quadProg=null, quadLoc=null;
function initQuadProgram(){
  const VSQ = `#version 300 es\nlayout(location=0) in vec2 a_pos;\nlayout(location=1) in vec2 a_uv;\nout vec2 v_uv;\nvoid main(){ v_uv = a_uv; gl_Position = vec4(a_pos,0.0,1.0); }`;
  const FSQ = `#version 300 es\nprecision highp float;\nin vec2 v_uv;\nuniform sampler2D u_tex;\nout vec4 o_color;\nvoid main(){ o_color = texture(u_tex, v_uv); }`;
  const v = compile(gl.VERTEX_SHADER, VSQ);
  const f = compile(gl.FRAGMENT_SHADER, FSQ);
  quadProg = link(v, f);
  quadLoc = { u_tex: gl.getUniformLocation(quadProg, 'u_tex') };
}

// small helper since GLSL normalize isn't available in JS
function normalizeVec3(v){
  const l = Math.hypot(v[0], v[1], v[2]) || 1;
  return [v[0]/l, v[1]/l, v[2]/l];
}

function crossVec3(a,b){
  return [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
}

/*** ---------- Skybox (implemented in skybox.js) ---------- ***/
/*** ---------- Boot ---------- ***/
// Fullscreen quad for compositing
let fsVao=null, fsVbo=null;
function ensureFullscreenGeom(){
  if(fsVao) return;
  fsVao = gl.createVertexArray();
  fsVbo = gl.createBuffer();
  gl.bindVertexArray(fsVao);
  gl.bindBuffer(gl.ARRAY_BUFFER, fsVbo);
  const verts = new Float32Array([
    -1,-1, 0,0,
     1,-1, 1,0,
    -1, 1, 0,1,
     1, 1, 1,1,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
}

function loadImage(url){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=>resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

(async function(){
  try{
    // Load heightmap and optional skybox in parallel
    const skyPromise = (typeof SKYBOX_URL === 'string' && SKYBOX_URL.trim().length > 0)
      ? loadImage(SKYBOX_URL)
      : Promise.resolve(null);
    const [img, skyImg, maskImg] = await Promise.all([
      loadImage(FINAL_DATA_URL),
      skyPromise,
      loadImage('blackmirror.png')
    ]);
    statusEl.textContent = `heightmap loaded: ${img.width}×${img.height} — building terrain…`;
    if(typeof buildTerrainFromImage === 'function'){
      await new Promise((resolve)=> setTimeout(resolve, 0));
      buildTerrainFromImage(gl, img, GRID, SIZE, HEIGHT_SCALE);
    }
    // Ensure plane and camera are initialized on the ground ASAP
    recenter();
    // Setup sky texture (via skybox.js if available)
    if(skyImg && typeof createSkyTexture === 'function') createSkyTexture(gl, skyImg);
    // Prefer textured sky by default when available
    if(typeof setProceduralSky === 'function') setProceduralSky(false);
    // Provide alpha mask texture for card clipping
    if(typeof postSetMirrorMaskTexture === 'function') postSetMirrorMaskTexture(gl, maskImg);
    // Load player glTF model
    try{
      const res = await loadGltf(gl, 'assets/3d/player/scene.gltf', { a_pos: 0, a_col: 1, a_norm: 2 });
      const b = res.bounds; const maxDim = Math.max(b.size[0], b.size[1], b.size[2]) || 1.0;
      const desired = 40.0; // target size in world units
      playerModel.drawables = res.drawables;
      playerModel.bounds = b;
      playerModel.scale = desired / maxDim;
      playerModel.ready = true;
      // Auto-align: derive from node transform 'nodeMatrix' of first drawable to account for model authoring axes
      if(res.drawables && res.drawables.length > 0){
        const m = res.drawables[0].nodeMatrix; // column-major
        // Columns represent model local axes in world space
        const ax = [ m[0], m[1], m[2] ];   // model +X in world
        const ay = [ m[4], m[5], m[6] ];   // model +Y
        const az = [ m[8], m[9], m[10] ];  // model +Z
        // Build a 3x3 that maps body basis (right,up,forward) to world axes using the model's authoring axes
        // We want forward -> -Z, up -> +Y, right -> +X, so set columns accordingly
        // MODEL_ALIGN acts on our computed body basis to nudge it into the model's authored frame
        MODEL_ALIGN = [ ax[0], ax[1], ax[2],
                        ay[0], ay[1], ay[2],
                       -az[0],-az[1],-az[2] ];
        // Additional yaw trim to face forward: -90 degrees about up
        PLAYER_MODEL_YAW_FIX = Math.PI * 0.5;
      }
      // Initialize airplane grounded placement once assets are ready if not already set
      if(!playerEntity.initialized){ recenter(); }
    }catch(e){ console.error('Failed to load player glTF', e); }
    statusEl.textContent = `ready.`;
    requestAnimationFrame(frame);
  }catch(e){
    console.error(e);
    statusEl.textContent = 'failed to load heightmap';
  }
})();


</script>
</body>
</html>

