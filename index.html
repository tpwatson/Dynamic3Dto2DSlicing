<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Layered-Painting Walking Sim (WebGL2)</title>
<style>
  html,body{margin:0;height:100%;background:#111;color:#ddd;font-family:system-ui}
  #ui{position:fixed;left:12px;top:72px;z-index:9;background:#0008;padding:8px 10px;border-radius:8px;max-width:360px}
  #ui label{display:block;font-size:12px;margin:6px 0 2px}
  #ui input[type=range]{width:220px;vertical-align:middle}
  #ui .val{display:inline-block;width:70px;text-align:right;font-size:12px;opacity:0.9}
  /* scope fullscreen sizing to primary GL canvas only */
  #gl{display:block;width:100vw;height:100vh;background:#050505}
  .btn{display:inline-block;background:#222;border:1px solid #444;padding:6px 8px;border-radius:6px;cursor:pointer}
  #uiToggle{position:fixed;left:12px;top:12px;z-index:10}
  /* Diorama card overlay (GL-drawn) — no DOM element needed */
  /* Black mirror overlay image */
  #mirrorOverlay{position:fixed;left:50%;top:50%;z-index:12;height:100vh;width:auto;pointer-events:none;user-select:none;object-fit:contain;transform:translate(-50%, -50%);} 
  /* Mobile virtual joysticks */
  .joy{position:fixed;bottom:22px;width:180px;height:180px;border-radius:50%;background:radial-gradient(closest-side, #ffffff10 0%, #ffffff08 60%, #00000000 61%);border:1px solid #333;display:none;z-index:13;touch-action:none}
  #joyL{left:22px}
  #joyR{right:22px}
  .joy .knob{position:absolute;left:50%;top:50%;width:72px;height:72px;border-radius:50%;background:#ffffff20;border:1px solid #666;transform:translate(-50%, -50%)}
  .joy.active .knob{background:#ffffff35}
  @media (hover: none) and (pointer: coarse){ .joy{display:block} }
</style>
</head>
<body>
<div id="uiToggle" class="btn">Hide UI (H)</div>
<div id="ui">
  <div><b>Layered Painting</b> — WASD to move, mouse to look. Click canvas to lock cursor.</div>
  <div>Layers: 14 • Stroke size: 8px • 5% random variation</div>
  <div id="status">loading heightmap…</div>
  <div style="margin-top:6px"><span class="btn" id="recenter">Recenter (R)</span></div>
  <div style="margin-top:8px">
    <label>View Far <span class="val" id="v_viewFar"></span></label>
    <input id="ctl_viewFar" type="range" min="50" max="50000" step="10">
    <label>Layer Max Dist <span class="val" id="v_layerMax"></span></label>
    <input id="ctl_layerMax" type="range" min="50" max="20000" step="10">
    <label>Stroke Px <span class="val" id="v_stroke"></span></label>
    <input id="ctl_stroke" type="range" min="2" max="48" step="1">
    <label>Variation <span class="val" id="v_var"></span></label>
    <input id="ctl_var" type="range" min="0" max="0.6" step="0.01">
    <label>Height Scale <span class="val" id="v_hscale"></span></label>
    <input id="ctl_hscale" type="range" min="10" max="1500" step="10">
    <label>Checker Size <span class="val" id="v_chkSize"></span></label>
    <input id="ctl_chkSize" type="range" min="1" max="200" step="1">
    <label>Checker Opacity <span class="val" id="v_chkAlpha"></span></label>
    <input id="ctl_chkAlpha" type="range" min="0" max="1" step="0.01">
    <label>Layer Passes (perf) <span class="val" id="v_layerPasses"></span></label>
    <input id="ctl_layerPasses" type="range" min="1" max="14" step="1">
    <label>Layer Res Scale (perf) <span class="val" id="v_resScale"></span></label>
    <input id="ctl_resScale" type="range" min="0.25" max="1" step="0.05">
    <label><input id="ctl_lockLayer" type="checkbox" checked> Lock Layer Max to View Far</label>
  </div>
</div>
  <div id="bandUi" style="margin-top:8px">
    <label>Preview Band (isolated)</label>
    <div id="bands"></div>
  </div>
<canvas id="gl"></canvas>
<img id="mirrorOverlay" src="blackmirror.png" alt="" />
<div id="joyL" class="joy"><div class="knob"></div></div>
<div id="joyR" class="joy"><div class="knob"></div></div>

<!-- Diorama Card will be drawn by WebGL inside the main canvas; no extra DOM needed -->

<script src="skybox.js"></script>
<script src="terrain.js"></script>
<script src="postcompose.js"></script>

<script>
/*** ---------- Config ---------- ***/
const HEIGHTMAP_DATA_URL = `heightmap2.png`;
/*
If you want to use your file instead, e.g. "heightmap.png", put it in same folder and:
const HEIGHTMAP_DATA_URL = "heightmap.png";
*/
// Equirectangular sky texture
const SKYBOX_URL = `skybox1.jpg`;

// Generate a procedural heightmap instead of loading external files
function generateHeightmap(width, height) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');
  
  // Create a gradient background (lowlands)
  const gradient = ctx.createLinearGradient(0, 0, width, height);
  gradient.addColorStop(0, '#2d4a2d');   // Dark green
  gradient.addColorStop(0.5, '#4a6b4a'); // Medium green
  gradient.addColorStop(1, '#2d4a2d');   // Dark green
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
  
  // Add mountains using multiple noise layers
  for (let i = 0; i < 5; i++) {
    const scale = 50 + i * 30;
    const amplitude = 0.3 - i * 0.05;
    const offsetX = Math.random() * 1000;
    const offsetY = Math.random() * 1000;
    
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height; y++) {
        const noise = (Math.sin((x + offsetX) / scale) * Math.cos((y + offsetY) / scale) + 1) / 2;
        const current = ctx.getImageData(x, y, 1, 1).data[0] / 255;
        const newValue = Math.min(1, current + noise * amplitude);
        
        // Color based on height
        let r, g, b;
        if (newValue < 0.4) {
          // Lowlands - green
          r = 45; g = 74; b = 45;
        } else if (newValue < 0.7) {
          // Midlands - brown
          r = 139; g = 115; b = 85;
        } else {
          // Highlands - white/snow
          r = 240; g = 240; b = 245;
        }
        
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }
  
  return canvas;
}

// Use external heightmap image provided by user
const FINAL_DATA_URL = HEIGHTMAP_DATA_URL;

  // Terrain resolution (vertices per side)
  const GRID = 512;           // try 128–512
const SIZE = 5000.0;         // world size (XZ span)
const HEIGHT_SCALE = 1600.0; // how tall the white peaks get
// Camera FOV used for both projection and skybox ray reconstruction
const FOVY = 60 * Math.PI / 180;

// Movement
const SPEED = 10.0;         // base walk speed (m/s)
const LOOK_SENS = 0.0023;   // mouse
const KEY_LOOK_SPEED = 1.8; // rad/sec for Arrow keys look
const JUMP = 8.0;           // simple hop
const GRAV = 25.0;
const EYE_HEIGHT = 2.0;     // player eye height above terrain
// Frame rate cap (testing)
const FPS_CAP_ENABLED = true;
const FPS_CAP = 30; // target FPS when cap is enabled
// Sprint/stamina (sedentary baseline)
const SPRINT_SPEED_TOP = 60.0;   // m/s for first ~5s
const SPRINT_SPEED_LONG = 50.0;  // m/s for next ~20-30s
const SPRINT_TOP_DURATION = 5.0; // seconds at 60
const SPRINT_LONG_DURATION = 25.0; // seconds at 50
const SPRINT_DECAY_DURATION = 20.0; // seconds to taper 50->0 if holding sprint
const SPRINT_TOTAL_DURATION = SPRINT_TOP_DURATION + SPRINT_LONG_DURATION + SPRINT_DECAY_DURATION; // ~50s
const STAMINA_DRAIN_PER_SEC = 1.0 / SPRINT_TOTAL_DURATION; // drains to 0 in ~50s of continuous sprinting
const STAMINA_RECOVER_REST = 1.0 / 45.0;  // full recover in ~45s if resting
const STAMINA_RECOVER_MOVE = 1.0 / 90.0;  // full recover in ~90s if walking

// Painterly / layers
const LAYERS = 14;
let VIEW_FAR = 13520.0;          // camera far plane (true view distance)
let LAYER_MAX_DIST = 3860.0;    // stylization range used for banding
let STROKE_PX = 2.0;          // base “pixel/brush” size (screen-space)
let VARIATION = 0.0;         // 5% size variation
let CHECKER_SIZE = 4.0;      // world units per checker cell
let CHECKER_ALPHA = 0.04;      // overlay opacity (0..1)
  let LAYER_PASSES = 14;         // how many bands to render (near-first)
let RES_SCALE = 0.25;           // 1.0 = full res, <1 = render to smaller FBOs
let LOCK_LAYER_TO_VIEW = true; // keep LAYER_MAX_DIST tracking VIEW_FAR

/*** ---------- WebGL2 Boilerplate ---------- ***/
const canvas = document.getElementById('gl');
const statusEl = document.getElementById('status');
const recenterBtn = document.getElementById('recenter');

let gl; // declare before first use (resize() checks this)
// Skybox handled by skybox.js

function resize() {
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const w = Math.floor(window.innerWidth * dpr);
  const h = Math.floor(window.innerHeight * dpr);
  canvas.width = w; canvas.height = h;
  canvas.style.width = '100vw'; canvas.style.height = '100vh';
  // Recreate FBOs after gl is initialized in boot sequence
  if(typeof gl !== 'undefined' && gl){ if(typeof postCreateLayerTargets==='function') postCreateLayerTargets(gl, canvas.width, canvas.height, LAYERS, RES_SCALE); }
}
resize(); addEventListener('resize', resize);

gl = canvas.getContext('webgl2', {antialias:false, alpha:false, powerPreference:'high-performance'});
if(!gl){ alert('WebGL2 required'); throw new Error('No WebGL2'); }
// Show GPU/driver info to help diagnose perf differences
try{
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const renderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : 'unknown';
  const vendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : 'unknown';
  const dprInfo = Math.min(2, window.devicePixelRatio || 1);
  if(statusEl) statusEl.textContent = `GPU: ${renderer} (${vendor}) — DPR: ${dprInfo} — loading heightmap…`;
}catch(e){ /* ignore */ }
// Initialize layer targets once GL exists
if(typeof postCreateLayerTargets==='function') postCreateLayerTargets(gl, canvas.width, canvas.height, LAYERS, RES_SCALE);

// UI bindings
const ctlViewFar = document.getElementById('ctl_viewFar');
const ctlLayerMax = document.getElementById('ctl_layerMax');
const ctlStroke = document.getElementById('ctl_stroke');
const ctlVar = document.getElementById('ctl_var');
const ctlHScale = document.getElementById('ctl_hscale');
const ctlChkSize = document.getElementById('ctl_chkSize');
const ctlChkAlpha = document.getElementById('ctl_chkAlpha');
const ctlLayerPasses = document.getElementById('ctl_layerPasses');
const ctlResScale = document.getElementById('ctl_resScale');
const ctlLockLayer = document.getElementById('ctl_lockLayer');
const vViewFar = document.getElementById('v_viewFar');
const vLayerMax = document.getElementById('v_layerMax');
const vStroke = document.getElementById('v_stroke');
const vVar = document.getElementById('v_var');
const vHScale = document.getElementById('v_hscale');
const vChkSize = document.getElementById('v_chkSize');
const vChkAlpha = document.getElementById('v_chkAlpha');
const vLayerPasses = document.getElementById('v_layerPasses');
const vResScale = document.getElementById('v_resScale');
const bandsDiv = document.getElementById('bands');
const uiRoot = document.getElementById('ui');
const bandUiRoot = document.getElementById('bandUi');
const uiToggle = document.getElementById('uiToggle');
let uiHidden = false;

function setUiHidden(v){
  uiHidden = v;
  if(uiRoot) uiRoot.style.display = v ? 'none' : '';
  if(bandUiRoot) bandUiRoot.style.display = v ? 'none' : '';
  if(uiToggle) uiToggle.textContent = v ? 'Show UI (H)' : 'Hide UI (H)';
}
if(uiToggle){ uiToggle.addEventListener('click', ()=> setUiHidden(!uiHidden)); }

function syncUI(){
  ctlViewFar.value = VIEW_FAR;
  ctlLayerMax.value = LAYER_MAX_DIST;
  ctlStroke.value = STROKE_PX;
  ctlVar.value = VARIATION;
  ctlHScale.value = HEIGHT_SCALE;
  ctlChkSize.value = CHECKER_SIZE;
  ctlChkAlpha.value = CHECKER_ALPHA;
  ctlLayerPasses.value = LAYER_PASSES;
  ctlResScale.value = RES_SCALE;
  ctlLockLayer.checked = LOCK_LAYER_TO_VIEW;
  vViewFar.textContent = VIEW_FAR.toFixed(0);
  vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0);
  vStroke.textContent = STROKE_PX.toFixed(0);
  vVar.textContent = VARIATION.toFixed(2);
  vHScale.textContent = HEIGHT_SCALE.toFixed(0);
  vChkSize.textContent = CHECKER_SIZE.toFixed(0);
  vChkAlpha.textContent = CHECKER_ALPHA.toFixed(2);
  vLayerPasses.textContent = LAYER_PASSES.toString();
  vResScale.textContent = RES_SCALE.toFixed(2);
}
syncUI();

// Build band preview buttons 0..13 and an All toggle
function buildBandButtons(){
  bandsDiv.innerHTML = '';
  const btnAll = document.createElement('span');
  btnAll.className = 'btn';
  btnAll.textContent = 'All';
  btnAll.onclick = ()=>{ activeBand = -1; };
  bandsDiv.appendChild(btnAll);
  for(let i=0;i<LAYERS;i++){
    const b = document.createElement('span');
    b.className = 'btn';
    b.style.marginLeft = '4px';
    b.textContent = String(i+1);
    b.onclick = ()=>{ activeBand = i; };
    bandsDiv.appendChild(b);
  }
}
buildBandButtons();

// Optional: stamina readout in status line
function updateStatus(){
  if(!statusEl) return;
  const pct = Math.round(stamina*100);
  statusEl.textContent = `stamina ${pct}%`;
}

ctlViewFar.addEventListener('input', ()=>{ VIEW_FAR = Number(ctlViewFar.value); vViewFar.textContent = VIEW_FAR.toFixed(0); });
ctlLayerMax.addEventListener('input', ()=>{ LAYER_MAX_DIST = Number(ctlLayerMax.value); vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0); });
ctlStroke.addEventListener('input', ()=>{ STROKE_PX = Number(ctlStroke.value); vStroke.textContent = STROKE_PX.toFixed(0); });
ctlVar.addEventListener('input', ()=>{ VARIATION = Number(ctlVar.value); vVar.textContent = VARIATION.toFixed(2); });
ctlHScale.addEventListener('change', ()=>{ // rebuild terrain with new vertical scale
  HEIGHT_SCALE = Number(ctlHScale.value);
  vHScale.textContent = HEIGHT_SCALE.toFixed(0);
  statusEl.textContent = 'rebuilding terrain…';
  // Re-load and rebuild to apply new scale consistently
  loadImage(FINAL_DATA_URL).then(img=>{ buildTerrainFromImage(img); statusEl.textContent='ready.'; });
});
ctlChkSize.addEventListener('input', ()=>{ CHECKER_SIZE = Number(ctlChkSize.value); vChkSize.textContent = CHECKER_SIZE.toFixed(0); });
ctlChkAlpha.addEventListener('input', ()=>{ CHECKER_ALPHA = Number(ctlChkAlpha.value); vChkAlpha.textContent = CHECKER_ALPHA.toFixed(2); });
ctlLayerPasses.addEventListener('input', ()=>{ LAYER_PASSES = Math.max(1, Math.min(LAYERS, Number(ctlLayerPasses.value))); vLayerPasses.textContent = LAYER_PASSES.toString(); });
ctlResScale.addEventListener('input', ()=>{ RES_SCALE = Number(ctlResScale.value); vResScale.textContent = RES_SCALE.toFixed(2); if(typeof postCreateLayerTargets==='function') postCreateLayerTargets(gl, canvas.width, canvas.height, LAYERS, RES_SCALE); });
ctlLockLayer.addEventListener('change', ()=>{ LOCK_LAYER_TO_VIEW = ctlLockLayer.checked; if(LOCK_LAYER_TO_VIEW){ LAYER_MAX_DIST = VIEW_FAR; ctlLayerMax.value = LAYER_MAX_DIST; vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0);} });
ctlViewFar.addEventListener('input', ()=>{ if(LOCK_LAYER_TO_VIEW){ LAYER_MAX_DIST = VIEW_FAR; ctlLayerMax.value = LAYER_MAX_DIST; vLayerMax.textContent = LAYER_MAX_DIST.toFixed(0);} });
// Fog controls removed

  // Freeze background toggle and start band selector (UI minimal: buttons)
  const freezeBtn = document.createElement('span'); freezeBtn.className='btn'; freezeBtn.style.marginLeft='6px'; freezeBtn.textContent='Freeze BG';
  const freezeBandInc = document.createElement('span'); freezeBandInc.className='btn'; freezeBandInc.style.marginLeft='6px'; freezeBandInc.textContent='BG Start++';
  const freezeBandDec = document.createElement('span'); freezeBandDec.className='btn'; freezeBandDec.style.marginLeft='6px'; freezeBandDec.textContent='BG Start--';
  uiRoot.appendChild(freezeBtn); uiRoot.appendChild(freezeBandDec); uiRoot.appendChild(freezeBandInc);
  let frozenStart = -1;
  function applyFrozen(){ if(typeof postSetFrozenStartBand==='function') postSetFrozenStartBand(frozenStart); }
  freezeBtn.onclick = ()=>{ frozenStart = (frozenStart<0) ? 10 : -1; applyFrozen(); };
  freezeBandInc.onclick = ()=>{ if(frozenStart<LAYERS-1){ frozenStart++; applyFrozen(); } };
  freezeBandDec.onclick = ()=>{ if(frozenStart>-1){ frozenStart--; applyFrozen(); } };

function compile(type,src){
  const s = gl.createShader(type);
  gl.shaderSource(s,src); gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s)); throw new Error('shader compile');
  }
  return s;
}
function link(vs,fs){
  const p = gl.createProgram();
  gl.attachShader(p,vs); gl.attachShader(p,fs); gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p)); throw new Error('link');
  }
  return p;
}

/*** ---------- Shaders ---------- ***/
// We pass world position + flat color. Fragment bins distance into 14 layers and applies
// a screen-space “brush/pixel” effect (consistent size regardless of distance).
const VS = `#version 300 es
layout(location=0) in vec3 a_pos;
layout(location=1) in vec3 a_col;
layout(location=2) in vec3 a_norm;

uniform mat4 u_proj, u_view, u_model;

out vec3 v_col;
out vec3 v_world;
out vec3 v_norm;
out vec2 v_worldXZ; // world-space XZ for checker pattern
out float v_eyeZ;   // positive view-space depth

void main(){
  vec4 world = u_model * vec4(a_pos,1.0);
  v_world = world.xyz;
  v_col = a_col;
  // Model is identity, but keep path for clarity/extension
  mat3 normalMat = mat3(u_model);
  v_norm = normalize(normalMat * a_norm);
  v_worldXZ = world.xz;
  vec4 viewPos = u_view * world;     // view space
  v_eyeZ = -viewPos.z;               // positive forward
  gl_Position = u_proj * viewPos;
}
`;

const FS = `#version 300 es
precision highp float;

in vec3 v_col;
in vec3 v_world;
in vec3 v_norm;
in vec2 v_worldXZ;
in float v_eyeZ;

out vec4 o_color;

uniform vec3  u_camPos;
uniform float u_maxDist;
uniform int   u_layers;
uniform vec2  u_res;
uniform float u_time;
uniform float u_strokePx;
uniform float u_variation;
uniform vec3  u_lightDir;   // direction TO light (world space)
uniform vec3  u_lightColor; // light RGB
uniform float u_ambient;    // ambient term
uniform float u_checkerSize; // world units per cell
uniform float u_checkerAlpha; // opacity of checker overlay
uniform int   u_activeBand; // -1 = render all; 0..13 = only that band (others discard)
// fog uniforms removed (disabled)

// Debug palette for 14 distance layers (index 0 = nearest, 13 = furthest)
const vec3 PALETTE[14] = vec3[14](
  vec3(0.02, 0.06, 0.02), // 1  black tinted green
  vec3(0.77, 0.60, 0.42), // 2  dark tan
  vec3(0.90, 0.78, 0.61), // 3  light tan
  vec3(0.55, 0.23, 0.16), // 4  reddish brown
  vec3(0.55, 0.43, 0.24), // 5  greenish brown
  vec3(0.30, 0.69, 0.31), // 6  green
  vec3(0.80, 0.86, 0.22), // 7  greenish yellow
  vec3(0.11, 0.37, 0.13), // 8  dark green
  vec3(0.50, 1.00, 0.83), // 9  light blue green
  vec3(0.00, 0.65, 0.65), // 10 medium blue green
  vec3(0.00, 0.30, 0.30), // 11 dark blue green
  vec3(0.78, 0.49, 1.00), // 12 light purple
  vec3(0.42, 0.00, 0.66), // 13 medium purple
  vec3(0.16, 0.00, 0.33)  // 14 dark purple
);

// hash helpers
float hash11(float p){ return fract(sin(p*127.1)*43758.5453); }
float hash21(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }

// quantize into N bands (0..N-1) based on distance
// Ensure the last band (N-1) contains everything at/above maxD
float bandIndex(float d, float maxD, float N){
  float eps = 1e-4;
  float denom = max(maxD / N, eps);
  float clamped = min(d, maxD - eps); // push values at/above maxD into final bin
  float idx = floor(clamped / denom);
  return clamp(idx, 0.0, N - 1.0);
}

  void main(){
  // distance from camera in world space (rotation-invariant)
  float d = distance(v_world, u_camPos);
  float idx = bandIndex(d, u_maxDist, float(u_layers));

  // Band mask: when u_activeBand >= 0, only draw that band
  if(u_activeBand >= 0 && int(idx) != u_activeBand){
    discard;
  }

  // Base color from palette by distance layer
  vec3 layerColor = PALETTE[int(idx)];
  // Lambert lighting
  float lambert = max(dot(normalize(v_norm), normalize(-u_lightDir)), 0.0);
  float lightIntensity = clamp(u_ambient + lambert, 0.0, 1.5);
  vec3 color = layerColor * lightIntensity * u_lightColor;

  // World-space checkerboard (black/white), independent of distance
  float cx = floor(v_worldXZ.x / max(1.0, u_checkerSize));
  float cz = floor(v_worldXZ.y / max(1.0, u_checkerSize));
  float checker = mod(cx + cz, 2.0);
  vec3 checkerCol = mix(vec3(0.0), vec3(1.0), checker);
  // Overlay checker onto color
  color = mix(color, checkerCol, clamp(u_checkerAlpha, 0.0, 1.0));

  // Screen-space “pseudo-pixels”: overlapping, rotated squares with ~5% size jitter
  vec2 uv = gl_FragCoord.xy;       // screen space
  float base = u_strokePx;
  // small per-layer variation (±5%) so bands don't align too perfectly
  float jitter = 1.0 + (u_variation * (hash11(idx+1.234) * 2.0 - 1.0));
  float cell = base * jitter;

  // snap to grid
  vec2 cellId = floor(uv / cell);
  vec2 cellCenter = (cellId + 0.5) * cell;

  // per-cell randoms
  float r = hash21(cellId + vec2(idx*13.1, idx*7.7));

  // slight drift per-layer to avoid moiré when moving
  vec2 drift = vec2(sin((idx+1.0)*0.7 + u_time*0.1), cos((idx+1.0)*0.9 + u_time*0.08)) * (cell*0.08);

  // rotate square slightly per-cell
  float ang = (r - 0.5) * 0.35; // ~±20°
  mat2 rot = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));
  vec2 p = rot * (uv - (cellCenter + drift));

  // half-size larger than cell/2 so squares overlap
  float halfSize = 0.65 * cell;
  // extra tiny jitter to keep sizes uneven (~±2%) layered on top of ±5%
  halfSize *= 0.98 + 0.04 * hash21(cellId + vec2(19.7, 3.1));

  // square SDF using L∞ norm, softened edges
  float edge = max(abs(p.x), abs(p.y)) / halfSize;
  float mask = smoothstep(1.05, 0.85, edge);

  // composite: each layer paints only inside its blotch cells, but keep some coverage
  // to avoid holes. We mix with a lighter “paper” to suggest texture.
  vec3 paper = vec3(0.0,0.0,0.0);
  vec3 painted = mix(color, color*0.85, 0.3 + 0.2*r); // slight variation per stamp

  // fake multi-stroke feel by modulating with a second threshold
  float ring = smoothstep(0.95, 0.7, edge);
  painted *= (0.9 + 0.1*ring);

  // depth fade per layer for separation
  // No fog: final color is just painted
  vec3 col = painted;

  // apply mask as coverage and alpha so transparent gaps remain between layers
  float coverage = clamp(mask, 0.0, 1.0);
  o_color = vec4(mix(paper, col, coverage), coverage);
}
`;

/*** ---------- Program & Buffers ---------- ***/
const vs = compile(gl.VERTEX_SHADER, VS);
const fs = compile(gl.FRAGMENT_SHADER, FS);
const prog = link(vs, fs);
gl.useProgram(prog);

const loc = {
  a_pos: 0, a_col: 1,
  u_proj: gl.getUniformLocation(prog,'u_proj'),
  u_view: gl.getUniformLocation(prog,'u_view'),
  u_model: gl.getUniformLocation(prog,'u_model'),
  u_camPos: gl.getUniformLocation(prog,'u_camPos'),
  u_maxDist: gl.getUniformLocation(prog,'u_maxDist'),
  u_layers: gl.getUniformLocation(prog,'u_layers'),
  u_res: gl.getUniformLocation(prog,'u_res'),
  u_time: gl.getUniformLocation(prog,'u_time'),
  u_strokePx: gl.getUniformLocation(prog,'u_strokePx'),
  u_variation: gl.getUniformLocation(prog,'u_variation'),
  u_lightDir: gl.getUniformLocation(prog,'u_lightDir'),
  u_lightColor: gl.getUniformLocation(prog,'u_lightColor'),
  u_ambient: gl.getUniformLocation(prog,'u_ambient'),
  u_checkerSize: gl.getUniformLocation(prog,'u_checkerSize'),
  u_checkerAlpha: gl.getUniformLocation(prog,'u_checkerAlpha'),
  u_activeBand: gl.getUniformLocation(prog,'u_activeBand'),
};

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const vbo = gl.createBuffer();
const ibo = gl.createBuffer();
let terrainAttribsSet = false;

// legacy counter (unused; terrain.js provides counts)
let indexCount = 0;
let activeBand = -1; // -1 = all

// Offscreen targets moved to postcompose.js

// Terrain sampling moved to terrain.js

/*** ---------- Heightmap -> Terrain Mesh ---------- ***/
// Implemented in terrain.js

/*** ---------- Camera / Controls ---------- ***/
let camPos = {x:0, y:30, z:-SIZE*0.9};
let yaw = 0, pitch = 0;
let velY = 0;
// Diorama card tilt (radians)
let cardTiltX = 0, cardTiltY = 0;
let cardTiltXTarget = 0, cardTiltYTarget = 0;
// Sprint/stamina state
let stamina = 1.0;             // 0..1
let sprintHoldTime = 0.0;      // seconds continuously holding sprint
let isSprinting = false;

const keys = {};
addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.key==='r'||e.key==='R') recenter(); if(e.key==='h'||e.key==='H') setUiHidden(!uiHidden); });
addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

function recenter(){
  camPos = {x:0, y:60, z:-SIZE*0.9};
  yaw = 0; pitch = 0; velY = 0;
  // snap to terrain if available
  const gy = sampleTerrainHeightAtWorld(camPos.x, camPos.z, SIZE);
  camPos.y = gy + EYE_HEIGHT;
}
recenterBtn.onclick = recenter;

canvas.addEventListener('click', ()=> canvas.requestPointerLock());
addEventListener('mousemove', e=>{
  if(document.pointerLockElement === canvas){
    yaw += e.movementX * LOOK_SENS;
    pitch += e.movementY * LOOK_SENS;
    pitch = Math.max(-1.2, Math.min(1.2, pitch));
  }
});

function getDir(){
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  const cp = Math.cos(pitch), sp = Math.sin(pitch);
  // forward in XZ with pitch applied
  return {
    x: sy * cp,
    y: -sp,
    z: -cy * cp
  };
}
function getRight(){
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  return { x: cy, y: 0, z: sy };
}

function tick(dt){
  const f = getDir();
  const r = getRight();
  let mx=0,my=0,mz=0;
  if(keys['w']){ mx += f.x; my += f.y; mz += f.z; }
  if(keys['s']){ mx -= f.x; my -= f.y; mz -= f.z; }
  if(keys['a']){ mx -= r.x; mz -= r.z; }
  if(keys['d']){ mx += r.x; mz += r.z; }
  // Mobile left joystick: forward/back/strafe
  if(joyLActive){
    mx += (f.x* -joyLVec.y) + (r.x* joyLVec.x);
    mz += (f.z* -joyLVec.y) + (r.z* joyLVec.x);
  }
  // Sprint mechanics (Shift key or right-joystick push-in optional later)
  const sprintKey = keys['shift'] === true;
  const moving = (Math.abs(mx) + Math.abs(mz)) > 1e-4;
  if(sprintKey && moving && stamina > 0){
    isSprinting = true;
    sprintHoldTime += dt;
    stamina = Math.max(0, stamina - STAMINA_DRAIN_PER_SEC * dt);
  } else {
    isSprinting = false;
    sprintHoldTime = 0;
    // recover slower while walking, faster while resting
    const rec = moving ? STAMINA_RECOVER_MOVE : STAMINA_RECOVER_REST;
    stamina = Math.min(1, stamina + rec * dt);
  }

  // Determine speed
  let curSpeed = SPEED;
  if(isSprinting){
    if(sprintHoldTime <= SPRINT_TOP_DURATION){
      curSpeed = SPRINT_SPEED_TOP;
    } else if(sprintHoldTime <= SPRINT_TOP_DURATION + SPRINT_LONG_DURATION){
      curSpeed = SPRINT_SPEED_LONG;
    } else {
      // decay linearly from SPRINT_SPEED_LONG to 0 over SPRINT_DECAY_DURATION
      const t = Math.min(1, (sprintHoldTime - (SPRINT_TOP_DURATION + SPRINT_LONG_DURATION)) / SPRINT_DECAY_DURATION);
      curSpeed = SPRINT_SPEED_LONG * (1 - t);
    }
    // If stamina is zero, clamp speed down further
    if(stamina <= 0){ curSpeed = Math.min(curSpeed, SPEED * 0.25); }
  }

  // Arrow keys for camera look (works well over remote desktop)
  if(keys['arrowleft']){ yaw -= KEY_LOOK_SPEED * dt; }
  if(keys['arrowright']){ yaw += KEY_LOOK_SPEED * dt; }
  if(keys['arrowup']){ pitch -= KEY_LOOK_SPEED * dt; }
  if(keys['arrowdown']){ pitch += KEY_LOOK_SPEED * dt; }
  // Mobile right joystick: camera look
  if(joyRActive){
    const lookRate = 1.8; // rad/sec at full deflection
    yaw += joyRVec.x * lookRate * dt;
    pitch += -joyRVec.y * lookRate * dt;
  }
  pitch = Math.max(-1.2, Math.min(1.2, pitch));
  const len = Math.hypot(mx,my,mz) || 1;
  camPos.x += (mx/len)*curSpeed*dt;
  camPos.z += (mz/len)*curSpeed*dt;

  // Ground follow: keep camera riding exactly above terrain
  const groundY = sampleTerrainHeightAtWorld(camPos.x, camPos.z, SIZE);
  camPos.y = groundY + EYE_HEIGHT;
  velY = 0;
}

/*** ---------- Matrices ---------- ***/
function perspective(fovy, aspect, near, far){
  const f = 1/Math.tan(fovy/2), nf = 1/(near-far);
  return new Float32Array([
    f/aspect,0,0,0,
    0,f,0,0,
    0,0,(far+near)*nf,-1,
    0,0,(2*far*near)*nf,0
  ]);
}
function lookAt(eye, center, up){
  const zx = eye.x-center.x, zy = eye.y-center.y, zz = eye.z-center.z;
  const zl = Math.hypot(zx,zy,zz);
  const zxN=zx/zl, zyN=zy/zl, zzN=zz/ zl;

  const xx = up.y*zzN - up.z*zyN;
  const xy = up.z*zxN - up.x*zzN;
  const xz = up.x*zyN - up.y*zxN;
  const xl = Math.hypot(xx,xy,xz);
  const xNx=xx/xl, xNy=xy/xl, xNz=xz/xl;

  const yx = zyN*xNz - zzN*xNy;
  const yy = zzN*xNx - zxN*xNz;
  const yz = zxN*xNy - zyN*xNx;

  return new Float32Array([
    xNx, yx, zxN, 0,
    xNy, yy, zyN, 0,
    xNz, yz, zzN, 0,
    -(xNx*eye.x + xNy*eye.y + xNz*eye.z),
    -(yx*eye.x + yy*eye.y + yz*eye.z),
    -(zxN*eye.x + zyN*eye.y + zzN*eye.z),
    1
  ]);
}

/*** ---------- Render Loop ---------- ***/
let last = performance.now();
let lastFrameTime = 0;
function frame(t){
  // FPS cap: skip frames to meet target cadence
  if(FPS_CAP_ENABLED){
    const minDelta = 1000 / FPS_CAP;
    if(t - lastFrameTime < minDelta){ requestAnimationFrame(frame); return; }
    lastFrameTime = t;
  }
  const dt = Math.min(0.033, (t-last)/1000); last = t;
  tick(dt);
  updateStatus();
  // no diorama tilt
  cardTiltX = 0; cardTiltY = 0; cardTiltXTarget = 0; cardTiltYTarget = 0;

  const aspect = canvas.width / canvas.height;
  const proj = perspective(FOVY, aspect, 0.1, VIEW_FAR);
  const f = getDir();
  const center = {x: camPos.x + f.x, y: camPos.y + f.y, z: camPos.z + f.z};
  const view = lookAt(camPos, center, {x:0,y:1,z:0});
  const model = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);

  gl.useProgram(prog);
  gl.uniformMatrix4fv(loc.u_proj,false,proj);
  gl.uniformMatrix4fv(loc.u_view,false,view);
  gl.uniformMatrix4fv(loc.u_model,false,model);
  gl.uniform3f(loc.u_camPos, camPos.x, camPos.y, camPos.z);
  gl.uniform1f(loc.u_maxDist, LAYER_MAX_DIST);
  gl.uniform1i(loc.u_layers, LAYERS);
  gl.uniform2f(loc.u_res, canvas.width, canvas.height);
  gl.uniform1f(loc.u_time, t*0.001);
  gl.uniform1f(loc.u_strokePx, STROKE_PX);
  gl.uniform1f(loc.u_variation, VARIATION);
  // we will set activeBand per-pass below
  // Lighting uniforms
  const lightDir = normalizeVec3([-0.6, -1.0, -0.4]); // coming from above-left
  gl.uniform3f(loc.u_lightDir, lightDir[0], lightDir[1], lightDir[2]);
  gl.uniform3f(loc.u_lightColor, 1.0, 1.0, 1.0);
  gl.uniform1f(loc.u_ambient, 0.35);
  // Checker uniforms
  gl.uniform1f(loc.u_checkerSize, CHECKER_SIZE);
  gl.uniform1f(loc.u_checkerAlpha, CHECKER_ALPHA);

  // 1) Render each band to its texture (draw multiple wrapped tiles in a 3x3 grid)
  gl.bindVertexArray(vao);
  // Bind terrain buffers from terrain module (vbo/ibo already filled)
  if(typeof bindTerrainBuffers==='function') bindTerrainBuffers(gl);
  const passesToRender = (activeBand>=0) ? 1 : LAYERS;
  for(let p=0;p<passesToRender;p++){
    const bandIndexToRender = (activeBand>=0) ? activeBand : p;
    if(typeof postBindLayerFbo==='function') postBindLayerFbo(gl, bandIndexToRender);
    const rw = Math.max(1, Math.floor(canvas.width * RES_SCALE));
    const rh = Math.max(1, Math.floor(canvas.height * RES_SCALE));
    gl.viewport(0,0,rw,rh);
    gl.enable(gl.DEPTH_TEST);
    // If this band is frozen and already captured, do not clear or redraw
    const shouldRender = (typeof postShouldRenderBand==='function') ? postShouldRenderBand(bandIndexToRender) : true;
    if(!shouldRender){
      continue;
    }
    gl.clearColor(0.0,0.0,0.0,0.0);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
    gl.uniform1i(loc.u_activeBand, bandIndexToRender);
    const terrainIndexCount = (typeof getTerrainIndexCount==='function') ? getTerrainIndexCount() : indexCount;
    // draw 3x3 tiles around camera by translating model matrix
    const translations = [-1,0,1];
    for(let ox of translations){
      for(let oz of translations){
        const tx = ox * SIZE * 2.0;
        const tz = oz * SIZE * 2.0;
        const modelT = new Float32Array([
          1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          tx,0,tz,1
        ]);
        gl.uniformMatrix4fv(loc.u_model,false,modelT);
        gl.drawElements(gl.TRIANGLES, terrainIndexCount, gl.UNSIGNED_INT, 0);
      }
    }
    // restore identity model for subsequent logic
    gl.uniformMatrix4fv(loc.u_model,false,model);
    if(typeof postMarkBandRendered==='function') postMarkBandRendered(bandIndexToRender);
  }

  // 2) Composite textures to screen as flat layers (nearest on top)
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0.0,0.0,0.0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  // Sky as background (drawn first)
  if(typeof drawSkyBackground === 'function') drawSkyBackground(gl, aspect, FOVY, getDir, canvas, SKYBOX_URL);

  // Fill background with solid color; skip fullscreen composition
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.disable(gl.DEPTH_TEST);
  gl.clearColor(0.02,0.02,0.02,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  // 2) Draw diorama exactly under the mirror overlay bounds (clipped), keeping 9:16 via the image sizing
  if(typeof postDrawDioramaCard === 'function'){
    const dpr = Math.min(2, window.devicePixelRatio||1);
    const mirror = document.getElementById('mirrorOverlay');
    if(mirror){
      const r = mirror.getBoundingClientRect();
      const x = Math.max(0, Math.floor(r.left * dpr));
      const y = Math.max(0, Math.floor(r.top * dpr));
      const w = Math.max(1, Math.floor(r.width * dpr));
      const h = Math.max(1, Math.floor(r.height * dpr));
      postDrawDioramaCard(gl, canvas.width, canvas.height, LAYERS, { x, y, w, h, tiltX: 0.0, tiltY: 0.0, depth: 0.0, zSpacing: 0.0, clip:true, maskThreshold: 0.4, activeBand });
    }
  }

  // Sync mirror overlay tilt with card tilt
  const mirror = document.getElementById('mirrorOverlay');
  if(mirror){ mirror.style.transform = `translate(-50%, -50%)`; }

  requestAnimationFrame(frame);
}

// Composite function: draws each band texture as a fullscreen quad back-to-front
function drawLayersFullscreen(){
  ensureFullscreenGeom();
  // Simple throwaway shader for textured quad
  if(!quadProg){ initQuadProgram(); }
  gl.useProgram(quadProg);
  gl.bindVertexArray(fsVao);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
  // Enable alpha blending so empty pixels (alpha=0) in each band texture
  // do not overwrite previously drawn bands during composition
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  // draw far to near so near band overprints
  for(let i=LAYER_PASSES-1;i>=0;i--){
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, layerTexs[i]);
    gl.uniform1i(quadLoc.u_tex, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  gl.disable(gl.BLEND);
}

let quadProg=null, quadLoc=null;
function initQuadProgram(){
  const VSQ = `#version 300 es\nlayout(location=0) in vec2 a_pos;\nlayout(location=1) in vec2 a_uv;\nout vec2 v_uv;\nvoid main(){ v_uv = a_uv; gl_Position = vec4(a_pos,0.0,1.0); }`;
  const FSQ = `#version 300 es\nprecision highp float;\nin vec2 v_uv;\nuniform sampler2D u_tex;\nout vec4 o_color;\nvoid main(){ o_color = texture(u_tex, v_uv); }`;
  const v = compile(gl.VERTEX_SHADER, VSQ);
  const f = compile(gl.FRAGMENT_SHADER, FSQ);
  quadProg = link(v, f);
  quadLoc = { u_tex: gl.getUniformLocation(quadProg, 'u_tex') };
}

// small helper since GLSL normalize isn't available in JS
function normalizeVec3(v){
  const l = Math.hypot(v[0], v[1], v[2]) || 1;
  return [v[0]/l, v[1]/l, v[2]/l];
}

function crossVec3(a,b){
  return [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
}

/*** ---------- Skybox (implemented in skybox.js) ---------- ***/
/*** ---------- Boot ---------- ***/
// Fullscreen quad for compositing
let fsVao=null, fsVbo=null;
function ensureFullscreenGeom(){
  if(fsVao) return;
  fsVao = gl.createVertexArray();
  fsVbo = gl.createBuffer();
  gl.bindVertexArray(fsVao);
  gl.bindBuffer(gl.ARRAY_BUFFER, fsVbo);
  const verts = new Float32Array([
    -1,-1, 0,0,
     1,-1, 1,0,
    -1, 1, 0,1,
     1, 1, 1,1,
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 16, 0);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 16, 8);
}

function loadImage(url){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=>resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

(async function(){
  try{
    // Load heightmap and skybox in parallel
    const [img, skyImg, maskImg] = await Promise.all([
      loadImage(FINAL_DATA_URL),
      loadImage(SKYBOX_URL),
      loadImage('blackmirror.png')
    ]);
    statusEl.textContent = `heightmap loaded: ${img.width}×${img.height} — building terrain…`;
    if(typeof buildTerrainFromImage === 'function'){
      await new Promise((resolve)=> setTimeout(resolve, 0));
      buildTerrainFromImage(gl, img, GRID, SIZE, HEIGHT_SCALE);
    }
    // Setup sky texture (via skybox.js if available)
    if(typeof createSkyTexture === 'function') createSkyTexture(gl, skyImg);
    // Provide alpha mask texture for card clipping
    if(typeof postSetMirrorMaskTexture === 'function') postSetMirrorMaskTexture(gl, maskImg);
    statusEl.textContent = `ready.`;
    requestAnimationFrame(frame);
  }catch(e){
    console.error(e);
    statusEl.textContent = 'failed to load heightmap';
  }
})();

  // ----- Mobile Virtual Joysticks -----
  const joyL = document.getElementById('joyL');
  const joyR = document.getElementById('joyR');
  const knobL = joyL ? joyL.querySelector('.knob') : null;
  const knobR = joyR ? joyR.querySelector('.knob') : null;
  let joyLActive=false, joyRActive=false;
  let joyLVec={x:0,y:0}, joyRVec={x:0,y:0};

  function setupJoystick(root, knob, onVec){
    if(!root || !knob) return;
    const radius = 80; // px
    function updateFromEvent(e){
      const t = ('touches' in e) ? e.touches[0] : e;
      const rect = root.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      let dx = t.clientX - cx;
      let dy = t.clientY - cy;
      const len = Math.hypot(dx,dy);
      const maxLen = radius;
      const cl = Math.min(1, len/maxLen);
      if(len>0){ dx = dx/len*cl; dy = dy/len*cl; } else { dx=0; dy=0; }
      const kx = dx*maxLen, ky = dy*maxLen;
      knob.style.transform = `translate(calc(-50% + ${kx}px), calc(-50% + ${ky}px))`;
      onVec({x:dx,y:dy});
    }
    function end(){ knob.style.transform='translate(-50%, -50%)'; onVec({x:0,y:0}); root.classList.remove('active'); }
    if(window.PointerEvent){
      root.addEventListener('pointerdown', e=>{ root.setPointerCapture(e.pointerId); root.classList.add('active'); updateFromEvent(e); });
      root.addEventListener('pointermove', e=>{ if(root.classList.contains('active')) updateFromEvent(e); });
      root.addEventListener('pointerup', end);
      root.addEventListener('pointercancel', end);
    } else {
      root.addEventListener('touchstart', e=>{ root.classList.add('active'); updateFromEvent(e); e.preventDefault(); }, {passive:false});
      root.addEventListener('touchmove', e=>{ if(root.classList.contains('active')) updateFromEvent(e); e.preventDefault(); }, {passive:false});
      root.addEventListener('touchend', end, {passive:false});
      root.addEventListener('touchcancel', end, {passive:false});
    }
  }

  setupJoystick(joyL, knobL, v=>{ joyLVec=v; joyLActive = (v.x!==0||v.y!==0); });
  setupJoystick(joyR, knobR, v=>{ joyRVec=v; joyRActive = (v.x!==0||v.y!==0); });

  function isTouchLike(){
    const coarse = window.matchMedia ? window.matchMedia('(pointer: coarse)').matches : false;
    return coarse || ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints>0);
  }
  function ensureJoystickVisibility(){
    if(!joyL||!joyR) return;
    if(isTouchLike()){
      joyL.style.display = 'block';
      joyR.style.display = 'block';
    }
  }
  ensureJoystickVisibility();
  addEventListener('resize', ensureJoystickVisibility);
</script>
</body>
</html>

